<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LAI Dashboard — 3 Tiers (Overview • Pillar • Pulse • Auto-Compute)</title>

  <!-- Plotly for charts -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <!-- SheetJS for Excel parsing -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --blue:#1f7fd6; --green:#18a76f; --ink:#0b1f33; --muted:#2f4556;
      --border:rgba(11,31,51,.16); --bg1:#e7f3ff; --bg2:#e7fbf2; --card:#ffffff;
      --warn:#d78b00; --bad:#d93b3b;
    }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1100px 520px at 15% 10%, var(--bg1), rgba(255,255,255,0)),
        radial-gradient(1100px 520px at 85% 20%, var(--bg2), rgba(255,255,255,0)),
        linear-gradient(180deg, #ffffff, #f7fbff);
      color:var(--ink); font-size:16px; line-height:1.45;
    }
    header{
      padding:14px 18px 12px 18px; border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.88); position:sticky; top:0; z-index:10; backdrop-filter: blur(8px);
    }
    .wrap{max-width:1250px;margin:0 auto;padding:14px 18px 40px;}
    h1{margin:0;font-size:20px;}
    .sub{margin-top:4px;color:var(--muted);font-size:13px;}
    .tabs{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .tabbtn{
      border:1px solid var(--border); background:#fff; border-radius:999px;
      padding:8px 12px; font-weight:900; cursor:pointer;
    }
    .tabbtn.active{border-color:rgba(31,127,214,.35); background:rgba(31,127,214,.08);}
    .grid{display:grid; gap:12px;}
    .grid-2{grid-template-columns:1.15fr 1fr;}
    @media (max-width: 980px){ .grid-2{grid-template-columns:1fr;} }
    .card{
      background:var(--card); border:1px solid var(--border); border-radius:16px;
      box-shadow:0 12px 28px rgba(11,31,51,.06); padding:14px;
    }
    .kpis{display:grid; grid-template-columns: repeat(4,1fr); gap:10px;}
    @media (max-width: 980px){ .kpis{grid-template-columns:1fr;} }
    .kpi{border:1px solid var(--border); border-radius:14px; padding:10px 12px; background:#fff;}
    .kpi .label{font-size:12px;color:var(--muted);font-weight:800;}
    .kpi .value{font-size:22px;font-weight:900;margin-top:2px;}
    .small{font-size:12px;color:var(--muted);}
    .pill{
      display:inline-block; padding:2px 10px; border-radius:999px;
      background:rgba(31,127,214,.10); border:1px solid rgba(31,127,214,.22);
      font-size:12px; font-weight:800;
    }
    .good{color:var(--green); font-weight:900;}
    .warn{color:var(--warn); font-weight:900;}
    .bad{color:var(--bad); font-weight:900;}
    .btnbar{display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px; align-items:center;}
    button{
      border:1px solid var(--border); background:#fff; border-radius:12px;
      padding:8px 12px; font-weight:900; cursor:pointer;
    }
    button.primary{border-color:rgba(31,127,214,.35); background:rgba(31,127,214,.08);}
    button.danger{border-color:rgba(217,59,59,.35); background:rgba(217,59,59,.08);}
    details{border:1px solid var(--border); border-radius:14px; padding:10px 12px; background:#fff; margin-top:10px;}
    summary{cursor:pointer; font-weight:900; color:var(--ink); list-style:none;}
    summary::-webkit-details-marker{display:none;}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .field{flex:1 1 320px; border:1px solid var(--border); border-radius:12px; padding:10px; background:#fff;}
    .field label{display:flex; justify-content:space-between; gap:10px; font-weight:900; font-size:13px;}
    .help{color:var(--muted); font-size:12px; margin-top:4px;}
    input[type="range"]{width:100%;}
    input, select{
      width:100%; padding:8px 10px; border:1px solid var(--border); border-radius:12px;
      font-size:14px; color:var(--ink); background:#fff;
    }
    .view{display:none;}
    .view.active{display:block;}
    .split{display:grid; grid-template-columns: 1.1fr .9fr; gap:12px;}
    @media (max-width: 980px){ .split{grid-template-columns:1fr;} }
    table{width:100%; border-collapse:collapse; font-size:13px;}
    th,td{border:1px solid var(--border); padding:8px; vertical-align:top;}
    th{background:rgba(31,127,214,.08); text-align:left;}
    .callout{border:1px dashed rgba(11,31,51,.25); border-radius:14px; padding:10px 12px; background: rgba(255,255,255,.7);}
    .errbar{display:none; border:1px solid rgba(217,59,59,.35); background:rgba(217,59,59,.08); color:var(--ink);
      border-radius:14px; padding:10px 12px; margin-top:12px;}
    .okbar{display:none; border:1px solid rgba(24,167,111,.35); background:rgba(24,167,111,.08); color:var(--ink);
      border-radius:14px; padding:10px 12px; margin-top:12px;}
    code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .inline{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--border); background:#fff;
      font-size:12px; font-weight:900; color:var(--ink);
    }
    .chip input{width:auto; padding:0; margin:0;}
  </style>
</head>

<body>
<header>
  <div class="wrap" style="padding:0 18px;">
    <h1>Language Access Index (LAI) — 3-Tier Navigation Dashboard</h1>
    <div class="sub">Tier 1: Self-Assessment • Tier 2: Repositioning • Tier 3: Performance Improvement (validated by encounter-level evidence)</div>
    <div class="tabs" aria-label="Navigation tabs">
      <button class="tabbtn active" id="tab_overview" data-view="overview">Tier 1 — Self-Assessment</button>
      <button class="tabbtn" id="tab_pillar" data-view="pillar">Tier 2 — Repositioning</button>
      <button class="tabbtn" id="tab_pulse" data-view="pulse">Tier 3 — Performance Improvement</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div id="errbar" class="errbar"></div>
  <div id="okbar" class="okbar"></div>

  <!-- OVERVIEW -->
  <section id="view_overview" class="view active">
    <div class="grid grid-2">
      <div class="card">
        <div class="btnbar">
          <button class="primary" id="btn_reset">Reset to defaults</button>
          <button id="btn_expand">Expand all pillars</button>
          <button id="btn_collapse">Collapse all pillars</button>
          <button id="btn_export_json">Export inputs (JSON)</button>
          <button id="btn_export_csv">Export scores (CSV)</button>
          <span class="chip" id="mode_chip">Mode: Manual (Tier 1)</span>
        </div>
        <div class="small">
          Tier 1 is a simplified preparedness proxy. Tier 3 can override Tier 1 using an encounter-level dataset (more precise).
        </div>
        <div id="pillars"></div>
      </div>

      <div class="card">
        <div class="kpis">
          <div class="kpi">
            <div class="label">LAI Pulse</div>
            <div class="value" id="lai_value">—</div>
            <div class="small" id="lai_band">—</div>
          </div>
          <div class="kpi">
            <div class="label">Risk signal</div>
            <div class="value" id="risk_label">—</div>
            <div class="small">Based on LAI thresholds</div>
          </div>
          <div class="kpi">
            <div class="label">Maturity stage</div>
            <div class="value" id="stage_label">—</div>
            <div class="small" id="stage_desc">—</div>
          </div>
          <div class="kpi">
            <div class="label">Top 3 improvement opportunities</div>
            <div class="small" id="opp_list">—</div>
          </div>
        </div>

        <div style="margin-top:10px;" id="gauge_overview"></div>
        <div style="margin-top:10px;" id="bar_overview"></div>

        <details>
          <summary>Pillar KPI reference (Tier 1 proxy inputs)</summary>
          <div style="margin-top:10px;">
            <table id="kpi_table"></table>
          </div>
        </details>
      </div>
    </div>
  </section>

  <!-- PILLAR DEEP DIVE -->
  <section id="view_pillar" class="view">
    <div class="grid">
      <div class="card">
        <div class="btnbar">
          <button class="primary" id="btn_back_overview_1">← Back to Overview</button>
          <button id="btn_go_pulse_1">Go to LAI Pulse →</button>
          <span class="chip" id="mode_chip_2">Mode: Manual (Tier 1)</span>
        </div>

        <div class="split">
          <div>
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <div style="font-weight:900;">Select pillar</div>
              <select id="pillar_select" style="max-width:420px;"></select>
              <span class="pill" id="pillar_score_badge">—</span>
            </div>
            <div class="small" style="margin-top:6px;">
              Tier 2 interprets signals from Tier 1 or Tier 3 (whichever is active) but does not change the underlying computation.
            </div>

            <div class="row" id="pillar_fields" style="margin-top:10px;"></div>

            <div class="callout" style="margin-top:10px;">
              <div style="font-weight:900;">Executive prompts (stage-aware)</div>
              <div class="small" id="exec_prompts" style="margin-top:6px;">—</div>
            </div>
          </div>

          <div>
            <div class="kpis" style="grid-template-columns:1fr; gap:10px;">
              <div class="kpi">
                <div class="label">Pillar score</div>
                <div class="value" id="pillar_score_value">—</div>
                <div class="small" id="pillar_score_band">—</div>
              </div>
              <div class="kpi">
                <div class="label">Nearest maturity “gate”</div>
                <div class="value" id="pillar_gate">—</div>
                <div class="small">Next stage threshold for this pillar</div>
              </div>
            </div>
            <div style="margin-top:10px;" id="pillar_gauge"></div>
            <div style="margin-top:10px;" id="pillar_breakdown"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- PULSE -->
  <section id="view_pulse" class="view">
    <div class="grid">
      <div class="card">
        <div class="btnbar">
          <button class="primary" id="btn_back_overview_2">← Back to Overview</button>
          <button id="btn_go_pillar_2">Go to Pillar Deep Dive →</button>
          <span class="chip" id="mode_chip_3">Mode: Manual (Tier 1)</span>
        </div>

        <!-- Upload card -->
        <div class="card" style="box-shadow:none; margin-bottom:12px;">
          <div style="font-weight:900; margin-bottom:6px;">Tier 3 Data Evidence Upload</div>
          <div class="small" style="margin-bottom:10px;">
            Upload an <b>.xlsx</b> (or <b>.csv</b>). Supported paths:
            <ul style="margin:6px 0 0 18px; padding:0;">
              <li><b>Encounter-level auto-compute (recommended):</b> sheet <code>Encounter_Level_Data</code> (computes all pillar KPIs from documented tasks and CPT signals).</li>
              <li><b>Pre-aggregated upload:</b> sheet <code>LAI_Pillar_Metrics</code> with <code>pillar_name</code>, <code>metric_1_value</code>, <code>metric_2_value</code>.</li>
            </ul>
          </div>

          <div class="inline">
            <input id="file_input" type="file" accept=".xlsx,.xls,.csv" />
            <button id="btn_download_template">Download template</button>
            <button class="danger" id="btn_clear_upload" disabled>Clear upload</button>

            <span class="chip" title="D2 weighting makes advanced maternal health encounters count more heavily in selected pillars.">
              <input type="checkbox" id="chk_advanced_mode" />
              <label for="chk_advanced_mode">Advanced Case Mode (D2)</label>
            </span>
          </div>

          <div class="small" style="margin-top:10px;">
            <b>Status:</b> <span id="upload_status">No file loaded.</span>
            <span id="upload_meta"></span>
          </div>
          <div class="small" style="margin-top:6px;">
            <b>Computation:</b> <span id="compute_mode">Tier 1 proxy</span>
          </div>
        
        <!-- Tier 3 drilldown & what-if simulator -->
        <div class="card" style="box-shadow:none; margin-bottom:12px;">
          <div style="font-weight:900; margin-bottom:6px;">Tier 3 Drilldown & What‑If Simulator</div>
          <div class="small" style="margin-bottom:10px;">
            Tier 3 is computed from the uploaded dataset. Use the drilldown to see how each pillar score is built from KPI components.
            Use the simulator to model improvements (without changing the file) and observe how the LAI Pulse and stage would change.
          </div>

          <div class="inline" style="margin-bottom:8px;">
            <span class="chip">
              <input type="checkbox" id="chk_sim_mode" />
              <label for="chk_sim_mode">Simulation Mode (apply improvements)</label>
            </span>
            <span class="chip" title="Resets simulation back to the computed baseline from the dataset.">
              <button id="btn_sim_reset">Reset simulation</button>
            </span>
          </div>

          <div class="grid grid-2" style="margin-top:8px;">
            <div class="card" style="box-shadow:none;">
              <div style="font-weight:900; margin-bottom:6px;">Pillar score table (computed vs simulated)</div>
              <div class="small" id="tier3_table_note">Upload an encounter-level dataset to populate this table.</div>
              <div style="overflow:auto; margin-top:8px;">
                <table id="tier3_pillar_table"></table>
              </div>
            </div>

            <div class="card" style="box-shadow:none;">
              <div style="display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:center;">
                <div style="font-weight:900;">Selected pillar drilldown</div>
                <select id="tier3_pillar_select" style="max-width:420px;"></select>
              </div>
              <div class="small" style="margin-top:6px;" id="tier3_pillar_context">—</div>

              <div style="overflow:auto; margin-top:8px;">
                <table id="tier3_component_table"></table>
              <div style="margin-top:10px;">
                <div style="font-weight:900; margin-bottom:6px;">Top 3 recommended actions for this pillar</div>
                <div class="small" id="tier3_actions_note">Upload an encounter-level dataset to generate recommendations.</div>
                <ol id="tier3_actions_list" class="small" style="margin:6px 0 0 18px; padding:0;"></ol>
              </div>

              </div>

              <details style="margin-top:10px;">
                <summary>Simulation controls for this pillar</summary>
                <div class="small" style="margin-top:8px;">
                  Adjust component completion rates (0–100). These model workflow/documentation improvements and recompute KPI1/KPI2 for the selected pillar.\n
                </div>
                <div class="row" id="tier3_sim_controls"></div>
              </details>
            </div>
          </div>

          <details style="margin-top:10px;">
            <summary>How the simulator works</summary>
            <div class="small" style="margin-top:8px;">
              <ul style="margin:0; padding-left:18px;">
                <li>Baseline values come from the uploaded dataset (<code>Encounter_Level_Data</code>).</li>
                <li>Each pillar has 2 KPIs. Each KPI is built from 1–N components (e.g., timestamp integrity, touchpoint completeness, documentation sufficiency).</li>
                <li>In Simulation Mode, component values you change replace the baseline components for that pillar only; all other pillars remain at baseline unless you adjust them too.</li>
                <li>Stage gating still applies: if any pillar is below a stage threshold, the overall stage cannot advance.</li>
              </ul>
            </div>
          </details>
        </div>
</div>

        <div class="kpis">
          <div class="kpi">
            <div class="label">LAI Pulse</div>
            <div class="value" id="lai_value_2">—</div>
            <div class="small" id="lai_band_2">—</div>
          </div>
          <div class="kpi">
            <div class="label">Risk signal</div>
            <div class="value" id="risk_label_2">—</div>
            <div class="small">Based on LAI thresholds</div>
          </div>
          <div class="kpi">
            <div class="label">Maturity stage</div>
            <div class="value" id="stage_label_2">—</div>
            <div class="small" id="stage_desc_2">—</div>
          </div>
          <div class="kpi">
            <div class="label">Stage gate rationale</div>
            <div class="small" id="stage_rationale">—</div>
          </div>
        </div>

        <div class="grid grid-2" style="margin-top:10px;">
          <div class="card" style="box-shadow:none;">
            <div style="font-weight:900; margin-bottom:6px;">Pulse gauge</div>
            <div id="gauge_pulse"></div>
            <div class="small" style="margin-top:8px;">
              Tip: Stage is determined by LAI thresholds AND “weakest-link” pillar constraints.
            </div>
          </div>

          <div class="card" style="box-shadow:none;">
            <div style="font-weight:900; margin-bottom:6px;">Preparedness map (lowest pillars drive the gate)</div>
            <div id="heatmap_pulse"></div>
          </div>
        </div>

        <details>
          <summary>Tier 3 computation notes (why it differs from Tier 1)</summary>
          <div class="small" style="margin-top:8px;">
            <ul style="margin:0; padding-left:18px;">
              <li><b>Tier 1</b> uses simplified proxy inputs to estimate preparedness.</li>
              <li><b>Tier 3</b> computes pillar KPIs from documented tasks and evidence fields (e.g., E/M defensibility, MDM elements, touchpoint coverage completeness, CCM/TCM completeness, timestamp integrity, rework proxy).</li>
              <li><b>Advanced Case Mode (D2)</b> increases the weight of advanced maternal health encounters for selected pillars (risk-constrained maturity).</li>
            </ul>
          </div>
        </details>
      </div>
    </div>
  </section>
</div>

<script>
  // ---- Helpers ----
  function slugify(s){
    return String(s).toLowerCase().replace(/&/g,"and").replace(/[^a-z0-9]+/g,"_").replace(/^_+|_+$/g,"");
  }
  function clamp(x, lo=0, hi=100){ return Math.max(lo, Math.min(hi, x)); }

  function normKey(k){ return String(k||"").trim().toLowerCase(); }
  function yn(v){
    // normalize Yes/No variants
    const s = String(v ?? "").trim().toLowerCase();
    if (s === "yes" || s === "y" || s === "true" || s === "1") return 1;
    if (s === "no" || s === "n" || s === "false" || s === "0") return 0;
    return null; // missing/unknown
  }
  function num(v){
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
  function isMissing(v){
    return v === null || v === undefined || (typeof v === "string" && v.trim()==="");
  }

  function weightedMean(values, weights){
    let sw=0, sx=0;
    for (let i=0;i<values.length;i++){
      const w = weights[i];
      const x = values[i];
      if (x === null || x === undefined) continue;
      if (!Number.isFinite(w) || w<=0) continue;
      sw += w; sx += w*x;
    }
    return sw>0 ? sx/sw : null;
  }
  function weightedRate(indicators, weights){
    // indicators: 0/1 values, possibly null
    const m = weightedMean(indicators, weights);
    return m===null ? null : 100*m;
  }
  function weightedMedian(values, weights){
    // values numeric, weights positive
    const pairs = [];
    for (let i=0;i<values.length;i++){
      const v = values[i];
      const w = weights[i];
      if (v===null || v===undefined) continue;
      if (!Number.isFinite(v) || !Number.isFinite(w) || w<=0) continue;
      pairs.push([v,w]);
    }
    if (!pairs.length) return null;
    pairs.sort((a,b)=>a[0]-b[0]);
    const totalW = pairs.reduce((a,b)=>a+b[1],0);
    let cum=0;
    for (const [v,w] of pairs){
      cum += w;
      if (cum >= totalW/2) return v;
    }
    return pairs[pairs.length-1][0];
  }

  function delayScoreFromMedian(mins){
    if (mins===null || mins===undefined) return 0;
    if (mins <= 10) return 100;
    if (mins <= 15) return 80;
    if (mins <= 20) return 60;
    if (mins <= 25) return 40;
    return 20;
  }

  function setText(id, txt){ const el=document.getElementById(id); if (el) el.textContent = txt; }
  function setHTML(id, html){ const el=document.getElementById(id); if (el) el.innerHTML = html; }
  function showErr(msg){ const e=document.getElementById("errbar"); e.style.display="block"; e.innerHTML = msg; }
  function clearErr(){ const e=document.getElementById("errbar"); e.style.display="none"; e.innerHTML = ""; }
  function showOk(msg){ const o=document.getElementById("okbar"); o.style.display="block"; o.innerHTML = msg; }

  const TIER2_PROMPTS = {
  "Access": [
      "Where are access delays most concentrated (arrival, triage, consults, discharge), and what operational evidence supports that conclusion?",
      "Which LEP encounter types lack timestamped interpreter engagement, and how does that gap distort reported wait-time performance?",
      "Where does short-term supply mismatch occur (languages, modalities, hours), and which 30-day control would most reduce delays?",
      "What minimum documentation threshold would verify interpreter access compliance ≥60 without increasing clinician burden?"
  ],
  "Patient Experience": [
      "Where do LEP experience scores diverge most sharply from expectations, and which communication step is most implicated?",
      "Which encounters lack documented comprehension confirmation (teach-back, repeat-back, visual aids)?",
      "Which service line shows the highest experience variance despite similar interpreter availability—and why?",
      "What single workflow change would most improve clarity without adding interpreter minutes?"
  ],
  "Outcomes": [
      "Where do LEP patients fall out of the care pathway (prescriptions, referrals, follow-up visits, preventive services)?",
      "Which outcome gaps are most plausibly driven by communication breakdowns versus access constraints?",
      "Which outcome measure would improve fastest if comprehension reliability increased by 10–15%?",
      "What is the lowest-effort evidence signal needed to link language access interventions to outcomes performance?"
  ],
  "Compliance": [
      "Where is compliance weakest: policy presence, workflow execution, or documentation traceability?",
      "Which required language-access touchpoints are most frequently undocumented despite services being delivered?",
      "Which department presents the highest regulatory exposure due to inconsistent evidence standards?",
      "What minimum audit-ready evidence package would reliably pass a spot review today?"
  ],
  "Patient Engagement": [
      "At which moments are LEP patients least engaged (care planning, consent, discharge, self-management)?",
      "Where is engagement assumed rather than verified, and what documentation would close that gap?",
      "Which modality (video, visual aids, teach-back) would most increase engagement without increasing visit length?",
      "What engagement metric would best predict downstream outcomes if measured consistently?"
  ],
  "Financial Stewardship": [
      "Where does language access failure most directly translate into cost (readmissions, LOS, denials, malpractice risk)?",
      "Which service line shows high interpreter utilization but low value capture?",
      "Where is over-reliance on vendor services masking workforce or workflow inefficiencies?",
      "What near-term intervention would most improve ROI visibility without financial system integration?"
  ],
  "Quality and Safety": [
      "Which adverse events or near misses are most plausibly linked to communication failure?",
      "Where are safety events documented without explicit language context?",
      "Which clinical pathway carries the highest compounded risk from language gaps?",
      "What single safety control would most reduce risk variance within one quarter?"
  ],
  "Workforce Development": [
      "Where is evidence weakest: missing timestamps, missing touchpoints, or missing attestations?",
      "Which staff groups are most often relied upon without verified proficiency or role clarity?",
      "Which documentation element would most reduce rework and downstream task burden in the next 30 days?",
      "What minimum evidence standard is needed to reliably meet the next maturity gate (≥60)?"
  ],
  "Workflow Optimization": [
      "Where does language access fail silently due to handoff breakdowns?",
      "Which workflows rely on individual heroics instead of standardized triggers?",
      "Which unit shows the greatest variability in execution—and why?",
      "What single workflow hard-stop would most improve consistency without slowing throughput?"
  ],
  "Technology Innovation": [
      "Where is technology underutilized relative to need?",
      "Which language-access data elements are generated but not captured or structured?",
      "Which tools introduce friction instead of reducing it?",
      "What is the smallest technical enhancement that would materially improve visibility and reliability?"
  ],
};

  // ---- Tier 1 proxy schema (kept for continuity) ----
  const METRICS = {"Access":{"m1":{"label":"% LEP patients who had <10 min wait time for interpreter/QBS in the Emergency Room","input":"band","units":"","bands":[["Under 10 min (ideal)",100],["10–15 min",80],["15–20 min",60],["20–25 min",40],[">25 min",20]],"default":"15–20 min"},"m2":{"label":"% alignment of physicians who speak non-English language(s) with LEP population in the geographic service area","input":"percent","units":"%","default":50},"weights":[0.6,0.4]},"Patient Experience":{"m1":{"label":"% HCAHPS differential among LEP and non-LEP pts in providers explaining things clearly","input":"gap_band","units":"pp","bands":[[2,100],[5,80],[10,60],[15,40],[1000000000,20]],"default":8},"m2":{"label":"% HCAHPS differential among LEP and non-LEP patients in patients understanding their treatment regimens","input":"gap_band","units":"pp","bands":[[2,100],[5,80],[10,60],[15,40],[1000000000,20]],"default":10},"weights":[0.5,0.5]},"Outcomes":{"m1":{"label":"% LEP patients who had prescriptions written and filled","input":"percent","units":"%","default":70},"m2":{"label":"% LEP patients who received recommended preventive services","input":"percent","units":"%","default":60},"weights":[0.5,0.5]},"Compliance":{"m1":{"label":"% LEP patients with interpreter access for touch-points requiring clinical engagement","input":"percent","units":"%","default":75},"m2":{"label":"% LEP encounters with documented interpreter/QBS use (excluding waivers)","input":"percent","units":"%","default":70},"weights":[0.5,0.5]},"Patient Engagement":{"m1":{"label":"% LEP patients who received teach-back","input":"percent","units":"%","default":40},"m2":{"label":"% LEP post-visit follow-up reached (auto + manual if needed)","input":"percent","units":"%","default":55},"weights":[0.5,0.5]},"Financial Stewardship":{"m1":{"label":"System cost savings from best practices (annual)","input":"dollars","units":"$","cap":5000000,"default":750000},"m2":{"label":"Hospital savings from reduced LOS among LEP patients (annual, per hospital)","input":"dollars","units":"$","cap":1500000,"default":250000},"weights":[0.55,0.45]},"Quality and Safety":{"m1":{"label":"30-day readmission rate for LEP patients","input":"band","units":"","bands":[["Under 10% (ideal)",100],["10–15%",80],["15–20%",60],["20–25%",40],[">25%",20]],"default":"15–20%"},"m2":{"label":"Gap in physical harm from adverse events (LEP vs non-LEP)","input":"gap_band","units":"pp","bands":[[0.5,100],[1.0,80],[2.0,60],[3.0,40],[1000000000,20]],"default":1.5},"weights":[0.55,0.45]},"Workforce Development":{"m1":{"label":"% staff trained in language access policy & preferred modality","input":"percent","units":"%","default":65},"m2":{"label":"% providers who are Qualified Bilingual Staff (QBS) or enrolled in QBS training","input":"percent","units":"%","default":20},"weights":[0.5,0.5]},"Workflow Optimization":{"m1":{"label":"% LEP touchpoints with documented interpreter/QBS use (7-touchpoint workflow)","input":"percent","units":"%","default":55},"m2":{"label":"Safety preparedness to minimize risk of harm for LEP patients (1–5)","input":"likert","units":"level","default":3},"weights":[0.55,0.45]},"Technology Innovation":{"m1":{"label":"% departments with tablets supporting VRI + audio interpreter modalities","input":"percent","units":"%","default":60},"m2":{"label":"% departments using tech-enabled documentation & automation (EMR doc, automated teach-back, etc.)","input":"percent","units":"%","default":45},"weights":[0.5,0.5]}};

  // Pillars shown in dashboard
  const PILLAR_ORDER = ["Access","Patient Experience","Outcomes","Compliance","Patient Engagement","Financial Stewardship","Quality and Safety","Workforce Development","Workflow Optimization","Technology Innovation"];
  // Map to internal IDs and to the dataset naming (Quality & Safety differs)
  const PILLAR_DISPLAY_TO_ID = Object.fromEntries(PILLAR_ORDER.map(p=>[p, slugify(p)]));
  const PILLAR_ID_TO_DISPLAY = Object.fromEntries(PILLAR_ORDER.map(p=>[slugify(p), p]));

  // Stage model (unchanged)
  const STAGES = [
    {name:"Stage 0", min:0,  label:"Unstable",          desc:"Reactive, inconsistent infrastructure; high variance by unit/service line."},
    {name:"Stage 1", min:40, label:"Foundational",      desc:"Core capabilities exist, but performance is uneven; basic standardization underway."},
    {name:"Stage 2", min:60, label:"Operational",       desc:"Reliable workflows across most touchpoints; measurable gains; fewer preventable failures."},
    {name:"Stage 3", min:75, label:"Optimized",         desc:"Proactive monitoring, strong documentation fidelity, and predictable outcomes for LEP patients."},
    {name:"Stage 4", min:85, label:"High-Reliability",  desc:"Sustained, audited, and continuously improved; resilient to demand surges and staffing shocks."}
  ];
  function stageFrom(lai, pillarScores){
    let candidate = STAGES[0];
    for (const s of STAGES){ if (lai >= s.min) candidate = s; }
    const lowPillars = Object.entries(pillarScores).filter(([p,sc]) => sc < candidate.min);
    if (lowPillars.length === 0){
      return {stage:candidate, gatedBy:null, rationale:`All pillars meet ≥${candidate.min}.`};
    }
    let gatedStage = STAGES[0];
    for (let i = STAGES.length-1; i >= 0; i--){
      const s = STAGES[i];
      const fails = Object.entries(pillarScores).filter(([p,sc]) => sc < s.min);
      if (fails.length === 0){ gatedStage = s; break; }
    }
    lowPillars.sort((a,b)=>a[1]-b[1]);
    const limiter = lowPillars[0];
    return {
      stage:gatedStage,
      gatedBy:{pillar: limiter[0], score: limiter[1], needed: candidate.min},
      rationale:`Gate constraint: ${limiter[0]} is ${limiter[1].toFixed(0)}/100 (<${candidate.min}).`
    };
  }

  function readinessBand(lai){
    if (lai >= 80) return ["High readiness","Lower risk","good"];
    if (lai >= 60) return ["Moderate readiness","Moderate risk","warn"];
    return ["Low readiness","Higher risk","bad"];
  }

  // ---- Mode state ----
  let MODE = "manual";          // manual | upload
  let COMPUTE = "tier1_proxy";  // tier1_proxy | encounter_auto | pillar_agg
  let uploadedRaw = null;       // {pillar: {m1, m2}} KPI scores (0-100) used by dashboard
  let uploadedMeta = {};

  // Tier 3 baseline details (computed from encounter-level evidence)
  let tier3Baseline = null;  // {pillarMetrics, pillarDetails, meta}
  let tier3Sim = null;       // same shape as tier3Baseline, after applying simulated component edits
  let simEdits = {};         // {pillar: {componentKey: value0to100}}
  let SIM_MODE = false;      // whether simulation is applied

  // Tier 3 filters and comparison state
  let tier3Filter = {service_line: 'All', unit_id: 'All'};
  let tier3Compare = {a: 'All', b: 'All'};

  function setMode(mode, computeModeLabel){
    MODE = mode;
    const label = (MODE === "upload") ? "Mode: Tier 3 Evidence" : "Mode: Manual (Tier 1)";
    ["mode_chip","mode_chip_2","mode_chip_3"].forEach(id=> setText(id, label));
    setText("compute_mode", computeModeLabel || (MODE==="upload" ? "Tier 3 evidence" : "Tier 1 proxy"));
    setManualEnabled(MODE !== "upload");
  }
  function setManualEnabled(enabled){
    for (const p of PILLAR_ORDER){
      for (const k of ["m1","m2"]){
        const el = document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__${k}`);
        if (el) el.disabled = !enabled;
      }
    }
    const r = document.getElementById("btn_reset");
    if (r) r.disabled = !enabled;
  }

  // ---- Tier 1 UI build ----
  const pillarsDiv = document.getElementById("pillars");
  function makeField(pillar, key, spec){
    const id = `${PILLAR_DISPLAY_TO_ID[pillar]}__${key}`;
    const field = document.createElement("div");
    field.className = "field";

    const label = document.createElement("label");
    const left = document.createElement("span"); left.textContent = spec.label;
    const right = document.createElement("span"); right.className="pill"; right.textContent = spec.units || "";
    label.appendChild(left); label.appendChild(right);

    const help = document.createElement("div"); help.className="help";
    let inputEl;

    if (spec.input === "percent"){
      inputEl = document.createElement("input");
      inputEl.type="range"; inputEl.min=0; inputEl.max=100; inputEl.step=1;
      inputEl.value = spec.default ?? 50;
      help.textContent = "Percent (higher is better).";
    } else if (spec.input === "band"){
      inputEl = document.createElement("select");
      for (const [opt,_] of spec.bands){
        const o=document.createElement("option"); o.value=opt; o.textContent=opt; inputEl.appendChild(o);
      }
      inputEl.value = spec.default ?? spec.bands[0][0];
      help.textContent = "Banded performance (best at top).";
    } else if (spec.input === "gap_band"){
      inputEl = document.createElement("input");
      inputEl.type="number"; inputEl.min=0; inputEl.max=50; inputEl.step=0.5;
      inputEl.value = spec.default ?? 5;
      help.textContent = "Absolute gap (pp). Lower is better (aim for 0).";
    } else if (spec.input === "dollars"){
      inputEl = document.createElement("input");
      inputEl.type="number"; inputEl.min=0; inputEl.max=spec.cap ?? 1000000; inputEl.step=25000;
      inputEl.value = spec.default ?? 0;
      help.textContent = `Annual dollars. Scaled 0–100 (cap $${Number(spec.cap||0).toLocaleString()}).`;
    } else if (spec.input === "likert"){
      inputEl = document.createElement("select");
      [1,2,3,4,5].forEach(v=>{ const o=document.createElement("option"); o.value=v; o.textContent=String(v); inputEl.appendChild(o); });
      inputEl.value = spec.default ?? 3;
      help.textContent = "Operational readiness (1=low, 5=high).";
    } else {
      inputEl = document.createElement("input");
      inputEl.type="range"; inputEl.min=0; inputEl.max=100; inputEl.step=1;
      inputEl.value = spec.default ?? 50;
      help.textContent = "Percent (higher is better).";
    }

    inputEl.id = id;
    inputEl.addEventListener("input", updateAll);
    inputEl.addEventListener("change", updateAll);

    const val = document.createElement("div");
    val.className="small"; val.style.marginTop="6px"; val.id = id + "__val";

    field.appendChild(label);
    field.appendChild(inputEl);
    field.appendChild(val);
    field.appendChild(help);
    return field;
  }

  function buildPillars(){
    pillarsDiv.innerHTML = "";
    for (const pillar of PILLAR_ORDER){
      const d=document.createElement("details");
      d.open = (pillar === "Access");
      const s=document.createElement("summary");
      s.innerHTML = `${pillar} <span class="small" id="score_${PILLAR_DISPLAY_TO_ID[pillar]}"></span>`;
      d.appendChild(s);

      const row=document.createElement("div"); row.className="row";
      row.appendChild(makeField(pillar,"m1",METRICS[pillar].m1));
      row.appendChild(makeField(pillar,"m2",METRICS[pillar].m2));
      d.appendChild(row);
      pillarsDiv.appendChild(d);
    }
  }

  function buildPillarSelect(){
    const sel=document.getElementById("pillar_select");
    sel.innerHTML="";
    for (const p of PILLAR_ORDER){
      const o=document.createElement("option"); o.value=p; o.textContent=p; sel.appendChild(o);
    }
    sel.addEventListener("change", renderPillarView);
  }

  // ---- Compute for Tier 1 or Tier 3 ----
  function getRaw(pillar, key, spec){
    // Tier 3 upload overrides
    if (MODE === "upload" && uploadedRaw && uploadedRaw[pillar] && uploadedRaw[pillar][key] != null){
      return uploadedRaw[pillar][key];
    }
    // Tier 1 controls
    const el=document.getElementById(`${PILLAR_DISPLAY_TO_ID[pillar]}__${key}`);
    if (!el) return spec.default;
    if (spec.input === "band") return el.value;
    return Number(el.value);
  }

  // Tier 3 upload always provides scores in v4; Tier 1 uses spec scoring.
  function scoreMetric(spec, raw){
    if (MODE === "upload"){
      return clamp(Number(raw)||0, 0, 100);
    }
    if (spec.input === "percent") return clamp(Number(raw)||0,0,100);
    if (spec.input === "band"){
      const map=new Map(spec.bands);
      return clamp(map.get(raw) ?? 0, 0, 100);
    }
    if (spec.input === "gap_band"){
      const a=Math.abs(Number(raw)||0);
      for (const [u,s] of spec.bands){ if (a <= u) return clamp(s,0,100); }
      return clamp(spec.bands[spec.bands.length-1][1],0,100);
    }
    if (spec.input === "dollars"){
      const v=Math.max(0,Number(raw)||0);
      const cap=Math.max(1,Number(spec.cap||1));
      return clamp((Math.log1p(v)/Math.log1p(cap))*100,0,100);
    }
    if (spec.input === "likert"){
      const v=Number(raw)||1;
      return clamp(((v-1)/4)*100,0,100);
    }
    return clamp(Number(raw)||0,0,100);
  }

  function compute(){
    const pillarScores = {};
    const metricScores = {};

    for (const pillar of PILLAR_ORDER){
      const w = METRICS[pillar].weights;
      const m1 = METRICS[pillar].m1;
      const m2 = METRICS[pillar].m2;

      const m1_raw = getRaw(pillar, "m1", m1);
      const m2_raw = getRaw(pillar, "m2", m2);

      const m1_score = scoreMetric(m1, m1_raw);
      const m2_score = scoreMetric(m2, m2_raw);

      const pscore = clamp((w[0]*m1_score) + (w[1]*m2_score), 0, 100);
      pillarScores[pillar] = pscore;

      metricScores[pillar] = {
        m1:{raw:m1_raw, score:m1_score, spec:m1, weight:w[0]},
        m2:{raw:m2_raw, score:m2_score, spec:m2, weight:w[1]}
      };

      // Update Tier 1 readouts (works even when disabled)
      const val1=document.getElementById(`${PILLAR_DISPLAY_TO_ID[pillar]}__m1__val`);
      const val2=document.getElementById(`${PILLAR_DISPLAY_TO_ID[pillar]}__m2__val`);
      if (val1) val1.textContent = `Score: ${m1_score.toFixed(0)}/100`;
      if (val2) val2.textContent = `Score: ${m2_score.toFixed(0)}/100`;

      const sc=document.getElementById(`score_${PILLAR_DISPLAY_TO_ID[pillar]}`);
      if (sc) sc.textContent = ` — ${pscore.toFixed(0)}/100`;
    }

    const lai = Object.values(pillarScores).reduce((a,b)=>a+b,0) / Math.max(1, PILLAR_ORDER.length);
    return {lai, pillarScores, metricScores};
  }

  // ---- Charts ----
  function canPlotly(){ return (typeof Plotly !== "undefined" && Plotly && Plotly.newPlot); }
  function renderGauge(divId, value, title){
    const el = document.getElementById(divId);
    if (!el) return;
    if (!canPlotly()){
      el.innerHTML = `<div class="small">Chart unavailable. Value: <b>${value.toFixed(0)}</b></div>`;
      return;
    }
    const data=[{type:"indicator", mode:"gauge+number", value:value, title:{text:title,font:{size:14}}, gauge:{axis:{range:[0,100]}}}];
    const layout={margin:{t:40,r:20,b:20,l:20}, height:240};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }
  function renderBar(divId, pillarScores){
    const el=document.getElementById(divId); if (!el) return;
    if (!canPlotly()){ el.innerHTML=`<div class="small">Chart unavailable.</div>`; return; }
    const x=Object.keys(pillarScores);
    const y=x.map(k=>pillarScores[k]);
    const data=[{type:"bar", x:x, y:y}];
    const layout={margin:{t:30,r:10,b:110,l:40}, height:320, xaxis:{tickangle:-35}, yaxis:{range:[0,100], title:"Score (0–100)"}};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }
  function renderPillarBreakdown(divId, pillar, metricScores){
    const el=document.getElementById(divId); if (!el) return;
    if (!canPlotly()){ el.innerHTML=`<div class="small">Chart unavailable.</div>`; return; }
    const ms=metricScores[pillar];
    const data=[{type:"bar", x:["KPI 1","KPI 2"], y:[ms.m1.score, ms.m2.score], hoverinfo:"y"}];
    const layout={margin:{t:20,r:10,b:40,l:40}, height:260, yaxis:{range:[0,100], title:"Score (0–100)"}};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }
  function renderHeatmap(divId, pillarScores){
    const el=document.getElementById(divId); if (!el) return;
    if (!canPlotly()){ el.innerHTML=`<div class="small">Chart unavailable.</div>`; return; }
    const x=PILLAR_ORDER;
    const z=[x.map(p=>pillarScores[p])];
    const data=[{type:"heatmap", x:x, y:["Pillars"], z:z, zmin:0, zmax:100, showscale:true}];
    const layout={margin:{t:10,r:10,b:90,l:50}, height:220};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }

  // ---- KPI reference table (Tier 1 only) ----
  function buildKpiTable(){
    const tbl=document.getElementById("kpi_table");
    let html="<tr><th>Pillar</th><th>KPI</th><th>Input type</th><th>Weight</th><th>Default</th></tr>";
    for (const p of PILLAR_ORDER){
      html += `<tr><td rowspan="2"><b>${p}</b></td><td>${METRICS[p].m1.label}</td><td>${METRICS[p].m1.input}</td><td>${METRICS[p].weights[0]}</td><td>${METRICS[p].m1.default}</td></tr>`;
      html += `<tr><td>${METRICS[p].m2.label}</td><td>${METRICS[p].m2.input}</td><td>${METRICS[p].weights[1]}</td><td>${METRICS[p].m2.default}</td></tr>`;
    }
    tbl.innerHTML=html;
  }

  // ---- Views ----
  function setActiveView(view){
    document.querySelectorAll(".view").forEach(v=>v.classList.remove("active"));
    document.getElementById("view_"+view).classList.add("active");
    document.querySelectorAll(".tabbtn").forEach(b=>b.classList.remove("active"));
    document.getElementById("tab_"+view).classList.add("active");
    if (view === "pillar") renderPillarView();
    if (view === "pulse") renderPulseView();
    if (view === "overview") updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
    window.scrollTo({top:0, behavior:"smooth"});
  }

  function renderPillarView(){
    const {pillarScores, metricScores} = compute();
    const p = document.getElementById("pillar_select").value || PILLAR_ORDER[0];

    const wrap=document.getElementById("pillar_fields");
    wrap.innerHTML="";
    const m1=metricScores[p].m1, m2=metricScores[p].m2;
    const f1=document.createElement("div"); f1.className="field";
    f1.innerHTML=`<label><span>${MODE==="upload" ? "Tier 3 KPI 1 (computed)" : "Tier 1 KPI 1 (proxy)"} — ${PILLAR_ORDER.includes(p)?p:""}</span><span class="pill">score</span></label>
      <div class="small" style="margin-top:6px;"><b>Score:</b> ${m1.score.toFixed(0)}/100</div>
      <div class="help">${MODE==="upload" ? "Computed from encounter-level evidence (tasks + documentation)." : "User-set proxy input."}</div>`;
    const f2=document.createElement("div"); f2.className="field";
    f2.innerHTML=`<label><span>${MODE==="upload" ? "Tier 3 KPI 2 (computed)" : "Tier 1 KPI 2 (proxy)"} — ${PILLAR_ORDER.includes(p)?p:""}</span><span class="pill">score</span></label>
      <div class="small" style="margin-top:6px;"><b>Score:</b> ${m2.score.toFixed(0)}/100</div>
      <div class="help">${MODE==="upload" ? "Computed from encounter-level evidence (tasks + documentation)." : "User-set proxy input."}</div>`;
    wrap.appendChild(f1); wrap.appendChild(f2);

    const score = pillarScores[p];
    setText("pillar_score_value", score.toFixed(0));
    const [rb,_,cls]=readinessBand(score);
    setText("pillar_score_band", rb);
    const badge=document.getElementById("pillar_score_badge");
    if (badge){ badge.classList.remove("good","warn","bad"); badge.classList.add(cls); badge.textContent=`${p}: ${score.toFixed(0)}/100`; }
    let next = STAGES.find(s=>score < s.min && s.min>0);
    if (!next) next = STAGES[STAGES.length-1];
    setText("pillar_gate", `≥${next.min}`);

    const qs = TIER2_PROMPTS[p] || [];
    const formatted = qs.map((q,i)=>`${i+1}. ${q}`).join(" ");
    setText("exec_prompts", formatted);

    renderGauge("pillar_gauge", score, `${p} — Pillar Score`);
    renderPillarBreakdown("pillar_breakdown", p, metricScores);
  }

  function renderPulseView(){
    const {lai, pillarScores} = compute();
    const [rb, rsk, cls] = readinessBand(lai);
    const st = stageFrom(lai, pillarScores);
    setText("lai_value_2", lai.toFixed(0));
    setText("lai_band_2", rb);
    setText("risk_label_2", rsk);
    setText("stage_label_2", `${st.stage.name}: ${st.stage.label}`);
    setText("stage_desc_2", st.stage.desc);
    setText("stage_rationale", st.rationale);
    renderGauge("gauge_pulse", lai, "LAI Pulse");
    renderHeatmap("heatmap_pulse", pillarScores);
  }

  function topOpportunities(pillarScores, n=3){
    return Object.entries(pillarScores).sort((a,b)=>a[1]-b[1]).slice(0,n);
  }

  function updateAll(){
    const {lai, pillarScores} = compute();
    const [rb, rsk, cls] = readinessBand(lai);
    const st = stageFrom(lai, pillarScores);
    const opp = topOpportunities(pillarScores, 3).map(([p,s])=>`${p} (${s.toFixed(0)})`).join(" • ");
    setText("lai_value", lai.toFixed(0));
    setText("lai_band", rb);
    setText("risk_label", rsk);
    setText("stage_label", `${st.stage.name}: ${st.stage.label}`);
    setText("stage_desc", st.stage.desc);
    setText("opp_list", opp || "—");
    renderGauge("gauge_overview", lai, "LAI Pulse");
    renderBar("bar_overview", pillarScores);
    if (document.getElementById("view_pillar").classList.contains("active")) renderPillarView();
    if (document.getElementById("view_pulse").classList.contains("active")) renderPulseView();
  }

  // ---- Tier 1 actions ----
  function resetDefaults(){
    if (MODE === "upload") return;
    for (const p of PILLAR_ORDER){
      for (const k of ["m1","m2"]){
        const spec=METRICS[p][k];
        const el=document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__${k}`);
        if (!el) continue;
        el.value = spec.default;
      }
    }
    updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
  }
  function expandAll(){ document.querySelectorAll("#pillars details").forEach(d=>d.open=true); }
  function collapseAll(){ document.querySelectorAll("#pillars details").forEach(d=>d.open=false); }

  // ---- Downloads ----
  function downloadText(filename, text, mime="text/plain"){
    const blob = new Blob([text], {type:mime});
    const url = URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download=filename;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
  function exportInputsJSON(){
    const inputs = {};
    for (const p of PILLAR_ORDER){
      inputs[p] = {};
      for (const k of ["m1","m2"]){
        inputs[p][k] = getRaw(p,k,METRICS[p][k]);
      }
    }
    downloadText("lai_inputs.json", JSON.stringify(inputs,null,2), "application/json");
  }
  function exportScoresCSV(){
    const {lai, pillarScores} = compute();
    const rows=[["Metric","Score"],["LAI",lai.toFixed(2)],...PILLAR_ORDER.map(p=>[p,pillarScores[p].toFixed(2)])];
    const csv = rows.map(r=>r.map(v=>String(v).replaceAll('"','""')).map(v=>`"${v}"`).join(",")).join("\n");
    downloadText("lai_scores.csv", csv, "text/csv");
  }

  // ---- Template download (for LAI_Pillar_Metrics) ----
  function downloadTemplate(){
    const header=["pillar_name","metric_1_value","metric_2_value","denominator","reporting_period"];
    const rp="Q1 2026";
    const rows=[header.join(",")];
    for (const p of PILLAR_ORDER){
      rows.push([`"${p}"`,50,50,100,`"${rp}"`].join(","));
    }
    downloadText("LAI_Pillar_Metrics_template.csv", rows.join("\n"), "text/csv");
  }

  // ---- Tier 3 Auto-compute from Encounter_Level_Data ----
  function getAdvancedFlag(row){
    // prefer advanced_case_flag, else exemplar_type == advanced_maternal
    const a = yn(row["advanced_case_flag"]);
    if (a !== null) return a===1;
    const et = String(row["exemplar_type"] ?? "").trim().toLowerCase();
    return et === "advanced_maternal";
  }

  function weightsFor(rows, pillarName){
    const advMode = document.getElementById("chk_advanced_mode")?.checked;
    if (!advMode) return rows.map(_=>1);

    // D2: weight advanced maternal encounters heavier in selected pillars
    const heavyPillars = new Set(["Compliance","Quality and Safety","Workflow Optimization","Access"]);
    const base = rows.map(r=> getAdvancedFlag(r) ? 2 : 1);
    if (heavyPillars.has(pillarName)) return base;
    // other pillars remain equal weighting
    return rows.map(_=>1);
  }

  function computeReworkPenalty(rows, weights){
    // penalty up to 25% based on attendant_tasks_count
    const vals = rows.map(r=>{
      const t = num(r["attendant_tasks_count"]);
      if (t===null) return null;
      const tn = Math.min(t/10, 1); // cap at 10
      return tn;
    });
    const meanT = weightedMean(vals, weights);
    if (meanT===null) return 1;
    return clamp(1 - 0.25*meanT, 0.75, 1.0);
  }

  function computeIntegrity(rows, weights){
    // Among interpreter_requested==Yes: request & start timestamps documented
    const ind = [];
    const w = [];
    for (let i=0;i<rows.length;i++){
      const r=rows[i];
      const req = yn(r["interpreter_requested"]);
      if (req !== 1) continue;
      const ok = (yn(r["interp_request_documented"])===1 && yn(r["interp_start_documented"])===1) ? 1 : 0;
      ind.push(ok);
      w.push(weights[i]);
    }
    const rate = weightedRate(ind, w);
    return rate===null ? 0 : (rate/100);
  }

  function computeTouchpointRatio(row){
    const fields = [
      "interp_or_qbs_preassessment_triage",
      "interp_or_qbs_hp",
      "interp_or_qbs_diagnosticrev",
      "interp_or_qbs_vitals",
      "interp_or_qbs_followup",
      "interp_or_qbs_dischargeplan",
      "interp_or_qbs_pteduc"
    ];
    let numYes=0, denom=0;
    for (const f of fields){
      const v = yn(row[f]);
      if (v===null) continue;
      denom += 1;
      if (v===1) numYes += 1;
    }
    if (denom===0) return null;
    return numYes/denom;
  }

  function documentationMaturityComposite(rows, weights){
    // Components: E/M completeness, MDM index, critical care sufficiency, teaching attestation, CCM completeness, TCM completeness
    // Each component returns a rate 0..100 or null; weighted by "elements required"
    const components = [];

    // 1) E/M completeness
    {
      const ind = rows.map(r=> yn(r["doc_em_mdm_time_complete"]));
      const rate = weightedRate(ind.map(v=>v===null?null:v), weights);
      components.push({name:"em_complete", rate:rate, w:2});
    }

    // 2) MDM data documentation index (3 fields)
    {
      const vals = rows.map(r=>{
        const a=yn(r["mdm_data_review_documents_present"]);
        const b=yn(r["mdm_independent_interpretation_documented"]);
        const c=yn(r["mdm_discussion_external_provider_documented"]);
        const arr=[a,b,c].filter(x=>x!==null);
        if (!arr.length) return null;
        return arr.reduce((s,x)=>s+x,0)/arr.length; // 0..1
      });
      const mean = weightedMean(vals, weights);
      const rate = mean===null ? null : 100*mean;
      components.push({name:"mdm_index", rate:rate, w:3});
    }

    // 3) Critical care sufficiency among has_99291
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["has_99291"])!==1) continue;
        const def=yn(r["critical_care_met_definition_documented"])===1;
        const act=yn(r["critical_care_activities_documented"])===1;
        const t = num(r["critical_care_time_minutes_documented"])!==null;
        ind.push((def && act && t) ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"critical_care", rate:rate, w:3});
    }

    // 4) Teaching attestation among has_gc or has_ge
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (!(yn(r["has_gc"])===1 || yn(r["has_ge"])===1)) continue;
        ind.push(yn(r["doc_teaching_attestation_complete"])===1 ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"teaching", rate:rate, w:2});
    }

    // 5) CCM completeness among has_ccm
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["has_ccm"])!==1) continue;
        const c=yn(r["ccm_patient_consent_documented"])===1;
        const p=yn(r["ccm_care_plan_documented"])===1;
        const t = num(r["ccm_time_minutes_documented"])!==null;
        ind.push((c && p && t) ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"ccm", rate:rate, w:3});
    }

    // 6) TCM completeness among has_tcm
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["has_tcm"])!==1) continue;
        const d=yn(r["tcm_discharge_date_documented"])===1;
        const ic=yn(r["tcm_interactive_contact_made"])===1;
        const f2f=yn(r["tcm_face_to_face_visit_completed"])===1;
        ind.push((d && ic && f2f) ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"tcm", rate:rate, w:3});
    }

    // Weighted mean of component rates (ignore null)
    let sw=0, sx=0;
    for (const c of components){
      if (c.rate===null || c.rate===undefined) continue;
      sw += c.w;
      sx += c.w * c.rate;
    }
    return sw>0 ? sx/sw : 0;
  }

  function computeFromEncounterRows(rows){
    // Compute two KPI scores (0..100) per pillar from encounter-level evidence fields
    const result = {};
    const reporting_period = rows[0]?.["reporting_quarter"] || rows[0]?.["reporting_period"] || "";
    const n = rows.length;

    // Access
    {
      const weights = weightsFor(rows,"Access");
      // median delay among interpreter_requested==Yes
      const delays=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["interpreter_requested"])!==1) continue;
        const d=num(r["interpreter_delay_minutes"]);
        if (d===null) continue;
        delays.push(d);
        w.push(weights[i]);
      }
      const med = weightedMedian(delays, w);
      const delayScore = delayScoreFromMedian(med);
      const integrity = computeIntegrity(rows, weights);
      const kpi1 = clamp(delayScore * integrity, 0, 100);

      // request reliability among interpreter_required==Yes
      const ind=[]; const ww=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["interpreter_required"])!==1) continue;
        ind.push(yn(r["interpreter_requested"])===1 ? 1 : 0);
        ww.push(weights[i]);
      }
      const kpi2 = weightedRate(ind, ww) ?? 0;

      result["Access"] = {m1:kpi1, m2:kpi2};
    }

    // Patient Experience
    {
      const weights = weightsFor(rows,"Patient Experience");
      const kpi1 = weightedRate(rows.map(r=>yn(r["provider_explained_understandably"])), weights) ?? 0;
      const kpi2 = weightedRate(rows.map(r=>yn(r["provider_listened"])), weights) ?? 0;
      result["Patient Experience"] = {m1:kpi1, m2:kpi2};
    }

    // Outcomes
    {
      const weights = weightsFor(rows,"Outcomes");
      const kpi1 = weightedRate(rows.map(r=>yn(r["preventive_service_completed"])), weights) ?? 0;
      const readm = weightedRate(rows.map(r=>yn(r["readmission_30d"])), weights) ?? 0;
      const kpi2 = clamp(100 - readm, 0, 100);
      result["Outcomes"] = {m1:kpi1, m2:kpi2};
    }

    // Compliance
    {
      const weights = weightsFor(rows,"Compliance");
      // composite: section_1557, clinical_language_documented, timestamp integrity (per encounter)
      const comp = rows.map(r=>{
        const a=yn(r["section_1557_documented"]);
        const b=yn(r["clinical_language_documented"]);
        const c=(yn(r["interp_request_documented"])===1 && yn(r["interp_start_documented"])===1) ? 1 : 0;
        const arr=[a,b,c].filter(x=>x!==null);
        if (!arr.length) return null;
        return arr.reduce((s,x)=>s+x,0)/arr.length; // 0..1
      });
      const kpi1 = (weightedMean(comp, weights) ?? 0) * 100;
      const kpi2 = weightedRate(rows.map(r=>yn(r["doc_interpreter_touchpoints_complete"])), weights) ?? 0;
      result["Compliance"] = {m1:clamp(kpi1,0,100), m2:kpi2};
    }

    // Patient Engagement
    {
      const weights = weightsFor(rows,"Patient Engagement");
      const kpi1 = weightedRate(rows.map(r=>yn(r["teach_back_documented"])), weights) ?? 0;
      const concord = rows.map(r=>{
        const a = String(r["discharge_instructions_language"] ?? "").trim().toLowerCase();
        const b = String(r["preferred_language"] ?? "").trim().toLowerCase();
        if (!a || !b) return null;
        return a===b ? 1 : 0;
      });
      const kpi2 = weightedRate(concord, weights) ?? 0;
      result["Patient Engagement"] = {m1:kpi1, m2:kpi2};
    }

    // Financial Stewardship
    {
      const weights = weightsFor(rows,"Financial Stewardship");
      const avoid = weightedRate(rows.map(r=>yn(r["avoidable_los_flag"])), weights) ?? 0;
      const miss = weightedRate(rows.map(r=>yn(r["missed_reimbursement_opportunity"])), weights) ?? 0;
      const kpi1 = clamp(100 - avoid, 0, 100);
      const kpi2_base = clamp(100 - miss, 0, 100);
      const penalty = computeReworkPenalty(rows, weights);
      const kpi2 = clamp(kpi2_base * penalty, 0, 100);
      result["Financial Stewardship"] = {m1:kpi1, m2:kpi2};
    }

    // Quality and Safety
    {
      const weights = weightsFor(rows,"Quality and Safety");
      const adv = weightedRate(rows.map(r=>yn(r["adverse_event_flag"])), weights) ?? 0;
      const kpi1 = clamp(100 - adv, 0, 100);
      const kpi2 = weightedRate(rows.map(r=>yn(r["safety_event_reported"])), weights) ?? 0;
      result["Quality and Safety"] = {m1:kpi1, m2:kpi2};
    }

    // Workforce Development
    {
      const weights = weightsFor(rows,"Workforce Development");
      const kpi1 = weightedRate(rows.map(r=>yn(r["staff_language_access_training_current"])), weights) ?? 0;
      const qbs = weightedRate(rows.map(r=>yn(r["provider_qbs_qualified"])), weights) ?? 0;
      const match = weightedRate(rows.map(r=>yn(r["provider_language_matches_patient"])), weights) ?? 0;
      const kpi2 = clamp((qbs + match)/2, 0, 100);
      result["Workforce Development"] = {m1:kpi1, m2:kpi2};
    }

    // Workflow Optimization
    {
      const weights = weightsFor(rows,"Workflow Optimization");
      const ratios = rows.map(r=>computeTouchpointRatio(r)); // 0..1
      const meanRatio = weightedMean(ratios, weights) ?? 0;
      const integrity = computeIntegrity(rows, weights);
      const kpi1 = clamp(100 * meanRatio * integrity, 0, 100);
      const kpi2 = weightedRate(rows.map(r=>yn(r["doc_interpreter_touchpoints_complete"])), weights) ?? 0;
      result["Workflow Optimization"] = {m1:kpi1, m2:kpi2};
    }

    // Technology Innovation
    {
      const weights = weightsFor(rows,"Technology Innovation");
      // tech utilization proxy: has_t1013 OR VRI modality
      const util = rows.map(r=>{
        const a = yn(r["has_t1013"]);
        const mod = String(r["interpreter_modality"] ?? "").trim().toLowerCase();
        const vri = (mod === "vri") ? 1 : 0;
        const arr=[a, vri].filter(x=>x!==null);
        if (!arr.length) return null;
        return arr.reduce((s,x)=>s+x,0)/arr.length; // 0..1
      });
      const utilRate = (weightedMean(util, weights) ?? 0) * 100;

      // tech integration level 1..5
      const ti = rows.map(r=>{
        const v = num(r["tech_integration_level"]);
        if (v===null) return null;
        return clamp(((v-1)/4)*100, 0, 100);
      });
      const tiScore = weightedMean(ti, weights) ?? 0;
      const kpi1 = clamp((utilRate + tiScore)/2, 0, 100);

      // documentation maturity composite + rework penalty
      const maturity = documentationMaturityComposite(rows, weights);
      const penalty = computeReworkPenalty(rows, weights);
      const kpi2 = clamp(maturity * penalty, 0, 100);

      result["Technology Innovation"] = {m1:kpi1, m2:kpi2};
    }

    // Build pillarDetails: store KPI values + component building blocks for drilldown & simulation
    const pillarDetails = {};

    // Helper to set detail
    function setDetail(pillar, kpi1, kpi2, components1, components2){
      pillarDetails[pillar] = {
        kpi1: kpi1, kpi2: kpi2,
        components: {
          kpi1: components1 || [],
          kpi2: components2 || []
        }
      };
    }

    // Populate details using the same intermediate quantities already computed above.
    // Note: values stored as 0–100 (percent-like) except median_delay_minutes (minutes).
    // Access
    try{
      const wA = weightsFor(rows,"Access");
      // integrity
      const integrityPct = (computeIntegrity(rows, wA) * 100);
      // median delay
      const delays=[]; const ww=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["interpreter_requested"])!==1) continue;
        const d=num(r["interpreter_delay_minutes"]);
        if (d===null) continue;
        delays.push(d); ww.push(wA[i]);
      }
      const med = weightedMedian(delays, ww);
      const delayScore = delayScoreFromMedian(med);
      const reqRel = weightedRate(rows.map(r=> (yn(r["interpreter_required"])===1 ? (yn(r["interpreter_requested"])===1 ? 1 : 0) : null)), wA) ?? 0;
      setDetail("Access", result["Access"].m1, result["Access"].m2,
        [
          {key:"median_delay_minutes", label:"Median interpreter delay (minutes)", value: (med===null? null : med), unit:"min", type:"minutes"},
          {key:"delay_score_band", label:"Delay score (banded mapping)", value: delayScore, unit:"/100", type:"score"},
          {key:"timestamp_integrity_pct", label:"Timestamp integrity (request+start documented)", value: integrityPct, unit:"%", type:"percent"}
        ],
        [
          {key:"request_reliability_pct", label:"Interpreter requested when required", value: reqRel, unit:"%", type:"percent"}
        ]
      );
    } catch(e){}

    // Patient Experience
    setDetail("Patient Experience", result["Patient Experience"].m1, result["Patient Experience"].m2,
      [{key:"explained_yes_pct", label:"Explained understandably (Yes)", value: result["Patient Experience"].m1, unit:"%", type:"percent"}],
      [{key:"listened_yes_pct", label:"Listened (Yes)", value: result["Patient Experience"].m2, unit:"%", type:"percent"}]
    );

    // Outcomes
    setDetail("Outcomes", result["Outcomes"].m1, result["Outcomes"].m2,
      [{key:"preventive_completed_pct", label:"Preventive service completed", value: result["Outcomes"].m1, unit:"%", type:"percent"}],
      [{key:"non_readmission_pct", label:"Not readmitted within 30 days", value: result["Outcomes"].m2, unit:"%", type:"percent"}]
    );

    // Compliance
    setDetail("Compliance", result["Compliance"].m1, result["Compliance"].m2,
      [
        {key:"section_1557_pct", label:"Section 1557 documented", value: (weightedRate(rows.map(r=>yn(r["section_1557_documented"])), weightsFor(rows,"Compliance")) ?? 0), unit:"%", type:"percent"},
        {key:"clinical_language_pct", label:"Clinical language documented", value: (weightedRate(rows.map(r=>yn(r["clinical_language_documented"])), weightsFor(rows,"Compliance")) ?? 0), unit:"%", type:"percent"},
        {key:"timestamp_integrity_pct", label:"Timestamp integrity (request+start documented)", value: (computeIntegrity(rows, weightsFor(rows,"Compliance"))*100), unit:"%", type:"percent"}
      ],
      [
        {key:"touchpoints_complete_pct", label:"Interpreter touchpoints complete (doc flag)", value: result["Compliance"].m2, unit:"%", type:"percent"}
      ]
    );

    // Patient Engagement
    setDetail("Patient Engagement", result["Patient Engagement"].m1, result["Patient Engagement"].m2,
      [{key:"teachback_doc_pct", label:"Teach-back documented", value: result["Patient Engagement"].m1, unit:"%", type:"percent"}],
      [{key:"discharge_concordance_pct", label:"Discharge language concordant", value: result["Patient Engagement"].m2, unit:"%", type:"percent"}]
    );

    // Financial Stewardship
    setDetail("Financial Stewardship", result["Financial Stewardship"].m1, result["Financial Stewardship"].m2,
      [{key:"non_avoidable_los_pct", label:"Not avoidable LOS", value: result["Financial Stewardship"].m1, unit:"%", type:"percent"}],
      [
        {key:"non_missed_reimb_pct", label:"No missed reimbursement opportunity", value: (100 - (weightedRate(rows.map(r=>yn(r["missed_reimbursement_opportunity"])), weightsFor(rows,"Financial Stewardship")) ?? 0)), unit:"%", type:"percent"},
        {key:"rework_penalty_pct", label:"Rework penalty (from attendant_tasks_count)", value: (computeReworkPenalty(rows, weightsFor(rows,"Financial Stewardship"))*100), unit:"%", type:"percent"}
      ]
    );

    // Quality and Safety
    setDetail("Quality and Safety", result["Quality and Safety"].m1, result["Quality and Safety"].m2,
      [{key:"non_adverse_event_pct", label:"No adverse event flag", value: result["Quality and Safety"].m1, unit:"%", type:"percent"}],
      [{key:"safety_event_reported_pct", label:"Safety event reported", value: result["Quality and Safety"].m2, unit:"%", type:"percent"}]
    );

    // Workforce Development
    setDetail("Workforce Development", result["Workforce Development"].m1, result["Workforce Development"].m2,
      [{key:"training_current_pct", label:"Staff language-access training current", value: result["Workforce Development"].m1, unit:"%", type:"percent"}],
      [
        {key:"qbs_pct", label:"Provider QBS qualified", value: (weightedRate(rows.map(r=>yn(r["provider_qbs_qualified"])), weightsFor(rows,"Workforce Development")) ?? 0), unit:"%", type:"percent"},
        {key:"language_match_pct", label:"Provider language matches patient", value: (weightedRate(rows.map(r=>yn(r["provider_language_matches_patient"])), weightsFor(rows,"Workforce Development")) ?? 0), unit:"%", type:"percent"}
      ]
    );

    // Workflow Optimization
    setDetail("Workflow Optimization", result["Workflow Optimization"].m1, result["Workflow Optimization"].m2,
      [
        {key:"touchpoint_coverage_pct", label:"Mean interpreter touchpoint coverage", value: result["Workflow Optimization"].m1, unit:"%", type:"percent"},
        {key:"timestamp_integrity_pct", label:"Timestamp integrity (request+start documented)", value: (computeIntegrity(rows, weightsFor(rows,"Workflow Optimization"))*100), unit:"%", type:"percent"}
      ],
      [{key:"touchpoints_complete_pct", label:"Interpreter touchpoints complete (doc flag)", value: result["Workflow Optimization"].m2, unit:"%", type:"percent"}]
    );

    // Technology Innovation
    setDetail("Technology Innovation", result["Technology Innovation"].m1, result["Technology Innovation"].m2,
      [
        {key:"tech_utilization_pct", label:"Tech utilization proxy (T1013 or VRI)", value: result["Technology Innovation"].m1, unit:"%", type:"percent"},
      ],
      [
        {key:"documentation_maturity_pct", label:"Documentation maturity composite", value: (documentationMaturityComposite(rows, weightsFor(rows,"Technology Innovation"))), unit:"%", type:"percent"},
        {key:"rework_penalty_pct", label:"Rework penalty (from attendant_tasks_count)", value: (computeReworkPenalty(rows, weightsFor(rows,"Technology Innovation"))*100), unit:"%", type:"percent"}
      ]
    );

    return {pillarMetrics: result, pillarDetails: pillarDetails, meta:{n, reporting_period}};
  }

  // ---- Upload parsing ----
  async function handleFile(file){
    clearErr();
    if (!file) return;

    const ext = file.name.toLowerCase().split(".").pop();
    let wb=null;
    let csvText=null;

    try{
      if (ext === "csv"){
        csvText = await file.text();
      } else {
        if (typeof XLSX === "undefined") throw new Error("XLSX library did not load.");
        const buf = await file.arrayBuffer();
        wb = XLSX.read(buf, {type:"array"});
      }
    } catch(e){
      showErr(`Could not read file. Error: <code>${String(e)}</code>`);
      return;
    }

    // 1) If Excel and has Encounter_Level_Data => auto compute
    if (wb){
      const sheetLower = wb.SheetNames.map(n=>[n, n.trim().toLowerCase()]);
      const sheetEncounter = sheetLower.find(([n,l])=>l==="encounter_level_data");
      const sheetPillar = sheetLower.find(([n,l])=>l==="lai_pillar_metrics");

      if (sheetEncounter){
        const ws = wb.Sheets[sheetEncounter[0]];
        const rows = XLSX.utils.sheet_to_json(ws, {defval:""});

        // compute and load
        const computed = computeFromEncounterRows(rows);
        tier3Baseline = computed;
        tier3Sim = null;
        simEdits = {};
        uploadedRaw = computed.pillarMetrics;
        uploadedMeta = {fileName:file.name, reporting_period: computed.meta.reporting_period, denominator_sum: computed.meta.n};

        setMode("upload", "Tier 3 auto-compute from Encounter_Level_Data");
        setText("upload_status", `Loaded encounter-level dataset: ${file.name}`);
        setHTML("upload_meta", ` • Reporting period: <b>${uploadedMeta.reporting_period || "—"}</b> • Encounters: <b>${uploadedMeta.denominator_sum.toLocaleString()}</b>`);
        document.getElementById("btn_clear_upload").disabled = false;
        COMPUTE = "encounter_auto";

        // sync Tier 1 controls to show scores (read-only) for transparency
        for (const p of PILLAR_ORDER){
          const el1=document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__m1`);
          const el2=document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__m2`);
          if (el1) el1.value = 50;
          if (el2) el2.value = 50;
        }

        updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
        populateFilterOptions(window.__lastEncounterRows || rows);
        renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
        runServiceLineComparison();
        showOk(`Tier 3 computed pillar KPIs from encounter-level evidence. Use the Tier 3 Drilldown & What‑If Simulator to unpack drivers. Toggle “Advanced Case Mode (D2)” to re-weight advanced maternal health encounters.`);
        return;
      }

      // 2) else if has LAI_Pillar_Metrics => use pre-aggregated
      if (sheetPillar){
        const ws = wb.Sheets[sheetPillar[0]];
        const rows = XLSX.utils.sheet_to_json(ws, {defval:""});
        const mapped = {};

        const first = rows[0] || {};
        const cols = Object.keys(first);
        const findCol = (name)=> cols.find(c=>normKey(c)===normKey(name));

        const cP = findCol("pillar_name");
        const c1 = findCol("metric_1_value");
        const c2 = findCol("metric_2_value");
        const cD = findCol("denominator");
        const cR = findCol("reporting_period");

        if (!cP || !c1 || !c2){
          showErr(`LAI_Pillar_Metrics is missing required columns. Found: <code>${cols.join(", ")}</code>`);
          return;
        }

        let denomSum=0, rp=null;
        for (const r of rows){
          const name = String(r[cP] ?? "").trim();
          if (!name) continue;
          // match to our pillar names
          const match = PILLAR_ORDER.find(p=>p.toLowerCase() === name.toLowerCase());
          if (!match) continue;
          mapped[match] = {m1: Number(r[c1]), m2: Number(r[c2])};
          if (cD) denomSum += Number(r[cD])||0;
          if (!rp && cR && String(r[cR]||"").trim()) rp = String(r[cR]).trim();
        }
        const missing = PILLAR_ORDER.filter(p=>!mapped[p]);
        if (missing.length){
          showErr(`LAI_Pillar_Metrics parsed but missing pillars: <code>${missing.join(", ")}</code>.`);
          return;
        }
        tier3Baseline = null;
        tier3Sim = null;
        simEdits = {};
        uploadedRaw = mapped;
        uploadedMeta = {fileName:file.name, reporting_period: rp, denominator_sum: denomSum || rows.length};
        setMode("upload", "Tier 3 using uploaded LAI_Pillar_Metrics");
        setText("upload_status", `Loaded aggregated pillar metrics: ${file.name}`);
        setHTML("upload_meta", ` • Reporting period: <b>${rp || "—"}</b> • Denominator: <b>${(uploadedMeta.denominator_sum||0).toLocaleString()}</b>`);
        document.getElementById("btn_clear_upload").disabled = false;
        COMPUTE = "pillar_agg";
        updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
        showOk(`Tier 3 loaded pre-aggregated pillar metrics. If you want automatic computation, include an Encounter_Level_Data sheet.`);
        return;
      }

      showErr(`Workbook does not contain <code>Encounter_Level_Data</code> or <code>LAI_Pillar_Metrics</code>. Found sheets: <code>${wb.SheetNames.join(", ")}</code>.`);
      return;
    }

    // CSV path: treat as LAI_Pillar_Metrics template
    if (csvText){
      const lines = csvText.split(/\r?\n/).filter(l=>l.trim().length>0);
      const headers = lines[0].split(",").map(h=>h.replace(/^"|"$/g,"").trim());
      const idx = (name)=> headers.findIndex(h=>normKey(h)===normKey(name));
      const iP = idx("pillar_name"), i1=idx("metric_1_value"), i2=idx("metric_2_value");
      if (iP<0 || i1<0 || i2<0){
        showErr(`CSV missing required columns. Required: pillar_name, metric_1_value, metric_2_value.`);
        return;
      }
      const mapped={};
      for (let i=1;i<lines.length;i++){
        const parts = lines[i].match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
        const get = (j)=> (parts[j] ?? "").replace(/^"|"$/g,"").trim();
        const pName = get(iP);
        const match = PILLAR_ORDER.find(p=>p.toLowerCase() === pName.toLowerCase());
        if (!match) continue;
        mapped[match] = {m1:Number(get(i1)), m2:Number(get(i2))};
      }
      const missing = PILLAR_ORDER.filter(p=>!mapped[p]);
      if (missing.length){
        showErr(`CSV parsed but missing pillars: <code>${missing.join(", ")}</code>.`);
        return;
      }
      tier3Baseline = null;
        tier3Sim = null;
        simEdits = {};
        tier3Baseline = null;
      tier3Sim = null;
      simEdits = {};
      uploadedRaw = mapped;
      uploadedMeta = {fileName:file.name};
      setMode("upload", "Tier 3 using uploaded pillar CSV");
      setText("upload_status", `Loaded aggregated pillar metrics: ${file.name}`);
      setHTML("upload_meta", "");
      document.getElementById("btn_clear_upload").disabled = false;
      COMPUTE = "pillar_agg";
      updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
      showOk(`Tier 3 loaded pre-aggregated pillar metrics from CSV.`);
    }
  }

  function clearUpload(){
    uploadedRaw = null;
    uploadedMeta = {};
    document.getElementById("file_input").value = "";
    document.getElementById("btn_clear_upload").disabled = true;
    setText("upload_status", "No file loaded.");
    setHTML("upload_meta","");
    COMPUTE = "tier1_proxy";
    setMode("manual", "Tier 1 proxy");
    resetDefaults();
    renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
    showOk(`Upload cleared. Back to Tier 1 proxy mode.`);
  }

  // When advanced mode toggles, recompute if encounter-level is active
  function onAdvancedToggle(){
    if (MODE !== "upload" || COMPUTE !== "encounter_auto") return;
    // We don't store the raw encounter rows; for simplicity, require re-upload or keep last rows.
    // To keep it interactive, we cache the last encounter rows in memory.
    if (window.__lastEncounterRows){
      const computed = computeFromEncounterRows(window.__lastEncounterRows);
      tier3Baseline = computed;
      // re-apply simulation edits if SIM_MODE
      if (SIM_MODE) { applySimulation(); }
      else { uploadedRaw = computed.pillarMetrics; }
      updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
      showOk(`Advanced Case Mode ${document.getElementById("chk_advanced_mode").checked ? "ON" : "OFF"} — Tier 3 recomputed from encounter evidence.`);
    }
  }

  // Patch handleFile to cache rows on encounter compute
  const _handleFile = handleFile;
  handleFile = async function(file){
    // wrap to cache when encounter sheet is used
    clearErr();
    if (!file) return;
    const ext = file.name.toLowerCase().split(".").pop();
    if (ext === "csv"){
      return _handleFile(file);
    }
    if (typeof XLSX === "undefined"){
      showErr("XLSX library did not load.");
      return;
    }
    try{
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, {type:"array"});
      const sheetLower = wb.SheetNames.map(n=>[n, n.trim().toLowerCase()]);
      const sheetEncounter = sheetLower.find(([n,l])=>l==="encounter_level_data");
      if (sheetEncounter){
        const ws = wb.Sheets[sheetEncounter[0]];
        const rows = XLSX.utils.sheet_to_json(ws, {defval:""});
        window.__lastEncounterRows = rows;
      } else {
        window.__lastEncounterRows = null;
      }
      // delegate to original logic by using same file again (no re-read needed for simplicity)
      // We'll call the inner logic by temporarily setting a global and reusing parse with wb, but keep simple:
    } catch(e){
      // ignore cache if fails
      window.__lastEncounterRows = null;
    }
    // Now call original _handleFile which will re-read; acceptable for our size (~1000 rows)
    return _handleFile(file);
  }

  
  // ---- Tier 3 Drilldown & Simulator ----
  function fmtVal(comp){
    if (comp===null || comp===undefined) return "—";
    if (typeof comp === "number"){
      return Number.isFinite(comp) ? (Math.round(comp*10)/10).toString() : "—";
    }
    return String(comp);
  }

  function getActiveTier3(){
    if (SIM_MODE && tier3Sim) return tier3Sim;
    if (tier3Baseline) return tier3Baseline;
    return null;
  }

  function ensureTier3Select(){
    const sel = document.getElementById("tier3_pillar_select");
    if (!sel) return;
    if (sel.options.length) return;
    PILLAR_ORDER.forEach(p=>{
      const o=document.createElement("option");
      o.value=p; o.textContent=p;
      sel.appendChild(o);
    });
    sel.addEventListener("change", ()=>{
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
    });
  }

  function buildPillarTable(active){
    const tbl = document.getElementById("tier3_pillar_table");
    if (!tbl) return;
    const rows = [];
    rows.push(`<tr>
      <th>Pillar</th>
      <th>KPI1</th>
      <th>KPI2</th>
      <th>Pillar score</th>
      <th>Δ vs baseline</th>
    </tr>`);

    // Baseline pillar score for delta
    const base = tier3Baseline ? tier3Baseline.pillarMetrics : null;

    for (const p of PILLAR_ORDER){
      const k1 = active?.pillarMetrics?.[p]?.m1;
      const k2 = active?.pillarMetrics?.[p]?.m2;
      const pscore = (k1===undefined||k2===undefined) ? null : clamp((METRICS[p].weights[0]*k1) + (METRICS[p].weights[1]*k2),0,100);
      const baseScore = base ? clamp((METRICS[p].weights[0]*base[p].m1) + (METRICS[p].weights[1]*base[p].m2),0,100) : null;
      const delta = (baseScore===null||pscore===null) ? null : (pscore - baseScore);
      rows.push(`<tr>
        <td><b>${p}</b></td>
        <td>${pscore===null ? "—" : (k1.toFixed(0))}</td>
        <td>${pscore===null ? "—" : (k2.toFixed(0))}</td>
        <td>${pscore===null ? "—" : (pscore.toFixed(0))}</td>
        <td>${delta===null ? "—" : (delta>=0? "+" : "") + delta.toFixed(0)}</td>
      </tr>`);
    }
    tbl.innerHTML = rows.join("");
  }

  function componentTableForPillar(active, pillar){
    const tbl = document.getElementById("tier3_component_table");
    const ctx = document.getElementById("tier3_pillar_context");
    if (!tbl || !ctx) return;

    if (!active || !active.pillarDetails || !active.pillarDetails[pillar]){
      ctx.textContent = "Upload an encounter-level dataset to see component-level drilldown for this pillar.";
      tbl.innerHTML = "<tr><th>Component</th><th>Value</th></tr><tr><td colspan='2'>—</td></tr>";
      document.getElementById("tier3_sim_controls").innerHTML = "";
      return;
    }

    const det = active.pillarDetails[pillar];
    ctx.textContent = `KPI1=${det.kpi1.toFixed(0)}/100, KPI2=${det.kpi2.toFixed(0)}/100. Components below show how Tier 3 derived those scores from the dataset.`;

    const lines = [];
    lines.push("<tr><th>Metric</th><th>Component</th><th>Value</th><th>Unit</th></tr>");
    for (const comp of det.components.kpi1){
      lines.push(`<tr><td><b>KPI1</b></td><td>${comp.label}</td><td>${fmtVal(comp.value)}</td><td>${comp.unit||""}</td></tr>`);
    }
    for (const comp of det.components.kpi2){
      lines.push(`<tr><td><b>KPI2</b></td><td>${comp.label}</td><td>${fmtVal(comp.value)}</td><td>${comp.unit||""}</td></tr>`);
    }
    tbl.innerHTML = lines.join("");

    buildSimControlsForPillar(pillar, det);
  }

  function buildSimControlsForPillar(pillar, det){
    const wrap = document.getElementById("tier3_sim_controls");
    if (!wrap) return;
    wrap.innerHTML = "";

    // Build sliders for percent-like components that are meaningful levers.
    // We do not expose minutes sliders everywhere; only for Access median delay.
    const controls = [];

    // Helper to add slider
    function addSlider(key, label, baselineVal, min, max, step){
      const cur = (simEdits[pillar] && simEdits[pillar][key]!==undefined) ? simEdits[pillar][key] : baselineVal;
      const field = document.createElement("div");
      field.className="field";
      field.innerHTML = `
        <label><span>${label}</span><span class="pill"><span id="sim_${slugify(pillar)}_${key}_val">${Math.round(cur)}</span></span></label>
        <input type="range" min="${min}" max="${max}" step="${step}" value="${cur}" id="sim_${slugify(pillar)}_${key}"/>
        <div class="help">Baseline: ${baselineVal===null||baselineVal===undefined ? "—" : Math.round(baselineVal)}.</div>
      `;
      field.querySelector("input").addEventListener("input", (e)=>{
        const v = Number(e.target.value);
        simEdits[pillar] = simEdits[pillar] || {};
        simEdits[pillar][key] = v;
        const lab = document.getElementById(`sim_${slugify(pillar)}_${key}_val`);
        if (lab) lab.textContent = Math.round(v);
        if (SIM_MODE) applySimulation();
      });
      wrap.appendChild(field);
    }

    // Access: allow improving median delay and timestamp integrity.
    if (pillar === "Access"){
      const comps = det.components.kpi1;
      const med = comps.find(c=>c.key==="median_delay_minutes")?.value;
      const integrity = comps.find(c=>c.key==="timestamp_integrity_pct")?.value;
      if (med!==null && med!==undefined){
        addSlider("median_delay_minutes", "Median interpreter delay (minutes) — simulate reduction", med, 0, 40, 1);
      }
      if (integrity!==null && integrity!==undefined){
        addSlider("timestamp_integrity_pct", "Timestamp integrity (%) — request+start documented", integrity, 0, 100, 1);
      }
      const reqRel = det.components.kpi2.find(c=>c.key==="request_reliability_pct")?.value;
      if (reqRel!==null && reqRel!==undefined){
        addSlider("request_reliability_pct", "Interpreter requested when required (%)", reqRel, 0, 100, 1);
      }
      return;
    }

    // Compliance: allow improving 1557, clinical language, touchpoints complete, integrity
    if (pillar === "Compliance"){
      const k1 = det.components.kpi1;
      const s1557 = k1.find(c=>c.key==="section_1557_pct")?.value;
      const clin = k1.find(c=>c.key==="clinical_language_pct")?.value;
      const integ = k1.find(c=>c.key==="timestamp_integrity_pct")?.value;
      const tpc = det.components.kpi2.find(c=>c.key==="touchpoints_complete_pct")?.value;
      if (s1557!==undefined) addSlider("section_1557_pct","Section 1557 documented (%)", s1557, 0, 100, 1);
      if (clin!==undefined) addSlider("clinical_language_pct","Clinical language documented (%)", clin, 0, 100, 1);
      if (integ!==undefined) addSlider("timestamp_integrity_pct","Timestamp integrity (%)", integ, 0, 100, 1);
      if (tpc!==undefined) addSlider("touchpoints_complete_pct","Interpreter touchpoints complete (%)", tpc, 0, 100, 1);
      return;
    }

    // Patient Engagement: teach-back + discharge concordance
    if (pillar === "Patient Engagement"){
      const tb = det.components.kpi1.find(c=>c.key==="teachback_doc_pct")?.value;
      const dc = det.components.kpi2.find(c=>c.key==="discharge_concordance_pct")?.value;
      if (tb!==undefined) addSlider("teachback_doc_pct","Teach-back documented (%)", tb, 0, 100, 1);
      if (dc!==undefined) addSlider("discharge_concordance_pct","Discharge language concordance (%)", dc, 0, 100, 1);
      return;
    }

    // Workflow Optimization: coverage + integrity + completeness
    if (pillar === "Workflow Optimization"){
      const cov = det.components.kpi1.find(c=>c.key==="touchpoint_coverage_pct")?.value;
      const integ = det.components.kpi1.find(c=>c.key==="timestamp_integrity_pct")?.value;
      const tpc = det.components.kpi2.find(c=>c.key==="touchpoints_complete_pct")?.value;
      if (cov!==undefined) addSlider("touchpoint_coverage_pct","Mean touchpoint coverage (%)", cov, 0, 100, 1);
      if (integ!==undefined) addSlider("timestamp_integrity_pct","Timestamp integrity (%)", integ, 0, 100, 1);
      if (tpc!==undefined) addSlider("touchpoints_complete_pct","Touchpoints complete (doc flag) (%)", tpc, 0, 100, 1);
      return;
    }

    // Technology Innovation: documentation maturity + rework penalty proxy (penalty slider is inverse of burden)
    if (pillar === "Technology Innovation"){
      const m = det.components.kpi2.find(c=>c.key==="documentation_maturity_pct")?.value;
      const r = det.components.kpi2.find(c=>c.key==="rework_penalty_pct")?.value;
      if (m!==undefined) addSlider("documentation_maturity_pct","Documentation maturity composite (%)", m, 0, 100, 1);
      if (r!==undefined) addSlider("rework_penalty_pct","Rework penalty factor (%) — higher is better", r, 75, 100, 1);
      return;
    }

    // Financial Stewardship: non-missed reimb + rework penalty
    if (pillar === "Financial Stewardship"){
      const nm = det.components.kpi2.find(c=>c.key==="non_missed_reimb_pct")?.value;
      const rp = det.components.kpi2.find(c=>c.key==="rework_penalty_pct")?.value;
      if (nm!==undefined) addSlider("non_missed_reimb_pct","No missed reimbursement opportunity (%)", nm, 0, 100, 1);
      if (rp!==undefined) addSlider("rework_penalty_pct","Rework penalty factor (%) — higher is better", rp, 75, 100, 1);
      return;
    }

    // Default: allow direct KPI nudges if desired
    addSlider("kpi1_override","KPI1 override (score 0–100)", det.kpi1, 0, 100, 1);
    addSlider("kpi2_override","KPI2 override (score 0–100)", det.kpi2, 0, 100, 1);
  }

  function applySimulation(){
    // Create tier3Sim from tier3Baseline by applying simEdits to component values and recomputing KPIs for edited pillars.
    if (!tier3Baseline) return;
    const base = tier3Baseline;
    const sim = JSON.parse(JSON.stringify(base)); // deep copy safe enough for numbers/objects

    // Helper to recompute KPI from components for specific pillars
    for (const pillar of Object.keys(simEdits)){
      const edits = simEdits[pillar] || {};
      if (!sim.pillarDetails || !sim.pillarDetails[pillar]) continue;
      const det = sim.pillarDetails[pillar];

      // Replace component values in detail tables (for display)
      const replace = (arr)=>arr.map(c=>{
        const k = c.key;
        if (edits[k]!==undefined){
          return Object.assign({}, c, {value: edits[k]});
        }
        return c;
      });
      det.components.kpi1 = replace(det.components.kpi1);
      det.components.kpi2 = replace(det.components.kpi2);

      // Now recompute KPI1/KPI2 for supported pillars using the same logic as v4, but on components.
      // Access
      if (pillar === "Access"){
        const med = edits["median_delay_minutes"]!==undefined ? edits["median_delay_minutes"] : det.components.kpi1.find(c=>c.key==="median_delay_minutes")?.value;
        const integ = edits["timestamp_integrity_pct"]!==undefined ? edits["timestamp_integrity_pct"] : det.components.kpi1.find(c=>c.key==="timestamp_integrity_pct")?.value;
        const delayScore = delayScoreFromMedian(med);
        const kpi1 = clamp(delayScore * (clamp(integ,0,100)/100), 0, 100);
        const kpi2 = clamp(edits["request_reliability_pct"]!==undefined ? edits["request_reliability_pct"] : det.components.kpi2.find(c=>c.key==="request_reliability_pct")?.value, 0, 100);
        det.kpi1 = kpi1; det.kpi2 = kpi2;
        sim.pillarMetrics[pillar].m1 = kpi1;
        sim.pillarMetrics[pillar].m2 = kpi2;
      } else if (pillar === "Compliance"){
        const s1557 = edits["section_1557_pct"]!==undefined ? edits["section_1557_pct"] : det.components.kpi1.find(c=>c.key==="section_1557_pct")?.value;
        const clin = edits["clinical_language_pct"]!==undefined ? edits["clinical_language_pct"] : det.components.kpi1.find(c=>c.key==="clinical_language_pct")?.value;
        const integ = edits["timestamp_integrity_pct"]!==undefined ? edits["timestamp_integrity_pct"] : det.components.kpi1.find(c=>c.key==="timestamp_integrity_pct")?.value;
        const kpi1 = clamp((clamp(s1557,0,100)+clamp(clin,0,100)+clamp(integ,0,100))/3, 0, 100);
        const kpi2 = clamp(edits["touchpoints_complete_pct"]!==undefined ? edits["touchpoints_complete_pct"] : det.components.kpi2.find(c=>c.key==="touchpoints_complete_pct")?.value, 0, 100);
        det.kpi1 = kpi1; det.kpi2 = kpi2;
        sim.pillarMetrics[pillar].m1 = kpi1;
        sim.pillarMetrics[pillar].m2 = kpi2;
      } else if (pillar === "Patient Engagement"){
        const tb = edits["teachback_doc_pct"]!==undefined ? edits["teachback_doc_pct"] : det.components.kpi1.find(c=>c.key==="teachback_doc_pct")?.value;
        const dc = edits["discharge_concordance_pct"]!==undefined ? edits["discharge_concordance_pct"] : det.components.kpi2.find(c=>c.key==="discharge_concordance_pct")?.value;
        const kpi1 = clamp(tb,0,100);
        const kpi2 = clamp(dc,0,100);
        det.kpi1=kpi1; det.kpi2=kpi2;
        sim.pillarMetrics[pillar].m1 = kpi1;
        sim.pillarMetrics[pillar].m2 = kpi2;
      } else if (pillar === "Workflow Optimization"){
        const cov = edits["touchpoint_coverage_pct"]!==undefined ? edits["touchpoint_coverage_pct"] : det.components.kpi1.find(c=>c.key==="touchpoint_coverage_pct")?.value;
        const integ = edits["timestamp_integrity_pct"]!==undefined ? edits["timestamp_integrity_pct"] : det.components.kpi1.find(c=>c.key==="timestamp_integrity_pct")?.value;
        const kpi1 = clamp(clamp(cov,0,100) * (clamp(integ,0,100)/100), 0, 100);
        const kpi2 = clamp(edits["touchpoints_complete_pct"]!==undefined ? edits["touchpoints_complete_pct"] : det.components.kpi2.find(c=>c.key==="touchpoints_complete_pct")?.value, 0, 100);
        det.kpi1=kpi1; det.kpi2=kpi2;
        sim.pillarMetrics[pillar].m1 = kpi1;
        sim.pillarMetrics[pillar].m2 = kpi2;
      } else if (pillar === "Technology Innovation"){
        const kpi1 = det.kpi1; // leave as computed unless overridden
        const m = edits["documentation_maturity_pct"]!==undefined ? edits["documentation_maturity_pct"] : det.components.kpi2.find(c=>c.key==="documentation_maturity_pct")?.value;
        const rp = edits["rework_penalty_pct"]!==undefined ? edits["rework_penalty_pct"] : det.components.kpi2.find(c=>c.key==="rework_penalty_pct")?.value;
        const kpi2 = clamp(clamp(m,0,100) * (clamp(rp,75,100)/100), 0, 100);
        det.kpi2 = kpi2;
        sim.pillarMetrics[pillar].m2 = kpi2;
      } else if (pillar === "Financial Stewardship"){
        const kpi1 = det.kpi1; // baseline already computed
        const nm = edits["non_missed_reimb_pct"]!==undefined ? edits["non_missed_reimb_pct"] : det.components.kpi2.find(c=>c.key==="non_missed_reimb_pct")?.value;
        const rp = edits["rework_penalty_pct"]!==undefined ? edits["rework_penalty_pct"] : det.components.kpi2.find(c=>c.key==="rework_penalty_pct")?.value;
        const kpi2 = clamp(clamp(nm,0,100) * (clamp(rp,75,100)/100), 0, 100);
        det.kpi2 = kpi2;
        sim.pillarMetrics[pillar].m2 = kpi2;
      } else {
        // generic overrides if present
        if (edits["kpi1_override"]!==undefined){
          det.kpi1 = clamp(edits["kpi1_override"],0,100);
          sim.pillarMetrics[pillar].m1 = det.kpi1;
        }
        if (edits["kpi2_override"]!==undefined){
          det.kpi2 = clamp(edits["kpi2_override"],0,100);
          sim.pillarMetrics[pillar].m2 = det.kpi2;
        }
      }
    }

    tier3Sim = sim;
    if (SIM_MODE){
      uploadedRaw = tier3Sim.pillarMetrics;
    } else {
      uploadedRaw = tier3Baseline.pillarMetrics;
    }
    updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
    renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
  }

  function renderTier3Drilldown(){
    ensureTier3Select();
    const note = document.getElementById("tier3_table_note");
    const active = getActiveTier3();

    if (!note) return;

    if (!active){
      note.textContent = "Upload an encounter-level dataset to populate Tier 3 drilldown.";
      const tbl = document.getElementById("tier3_pillar_table");
      if (tbl) tbl.innerHTML = "<tr><th>Pillar</th><th>KPI1</th><th>KPI2</th><th>Pillar score</th><th>Δ vs baseline</th></tr><tr><td colspan='5'>—</td></tr>";
      componentTableForPillar(null, "Access");
      recommendActions(null, "Access");
      return;
    }

    note.textContent = SIM_MODE ? "Showing SIMULATED scores (Simulation Mode ON)." : "Showing COMPUTED scores from dataset.";

    buildPillarTable(active);
    const sel = document.getElementById("tier3_pillar_select");
    const pillar = sel ? (sel.value || "Access") : "Access";
    componentTableForPillar(active, pillar);
    recommendActions(active, pillar);
  }

  function resetSimulation(){
    simEdits = {};
    tier3Sim = null;
    if (tier3Baseline && MODE==="upload" && COMPUTE==="encounter_auto"){
      uploadedRaw = tier3Baseline.pillarMetrics;
      updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
    }
    renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
    showOk("Simulation reset to baseline.");
  }

  function onSimToggle(){
    SIM_MODE = document.getElementById("chk_sim_mode").checked;
    if (!tier3Baseline){
      SIM_MODE = false;
      document.getElementById("chk_sim_mode").checked = false;
      showErr("Simulation requires an encounter-level upload (Encounter_Level_Data).");
      return;
    }
    if (SIM_MODE){
      applySimulation();
      showOk("Simulation Mode ON — adjust component sliders to model improvements.");
    } else {
      uploadedRaw = tier3Baseline ? tier3Baseline.pillarMetrics : uploadedRaw;
      updateAll();
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
      showOk("Simulation Mode OFF — showing computed baseline.");
    }
  }


  
  // ---- Tier 3 Filters + Comparison + Action Recommendations ----
  function uniq(arr){
    return Array.from(new Set(arr.filter(x=>x!==null && x!==undefined && String(x).trim()!==''))).sort((a,b)=>String(a).localeCompare(String(b)));
  }

  function getField(row, name){
    // tolerant access: tries exact, then case-insensitive key match once
    if (row[name] !== undefined) return row[name];
    const target = normKey(name);
    const key = Object.keys(row).find(k=>normKey(k)===target);
    return key ? row[key] : undefined;
  }

  function populateFilterOptions(rows){
    const sl = uniq(rows.map(r=>String(getField(r,"service_line") ?? "").trim()).filter(s=>s));
    const un = uniq(rows.map(r=>String(getField(r,"unit_id") ?? "").trim()).filter(s=>s));

    const fltSL = document.getElementById("flt_service_line");
    const fltU = document.getElementById("flt_unit_id");
    const cmpA = document.getElementById("cmp_a");
    const cmpB = document.getElementById("cmp_b");
    if (!fltSL || !fltU || !cmpA || !cmpB) return;

    function setSelect(sel, options, includeAll=true){
      const prev = sel.value || "All";
      sel.innerHTML = "";
      if (includeAll){
        const o=document.createElement("option"); o.value="All"; o.textContent="All";
        sel.appendChild(o);
      }
      options.forEach(v=>{
        const o=document.createElement("option"); o.value=v; o.textContent=v; sel.appendChild(o);
      });
      // restore if exists
      const has = Array.from(sel.options).some(o=>o.value===prev);
      sel.value = has ? prev : (includeAll ? "All" : (options[0]||"All"));
    }

    setSelect(fltSL, sl, true);
    setSelect(fltU, un, true);
    setSelect(cmpA, ["All", ...sl].filter((v,i,a)=>a.indexOf(v)===i), false);
    setSelect(cmpB, ["All", ...sl].filter((v,i,a)=>a.indexOf(v)===i), false);

    // sensible defaults
    if (cmpA.value === "All") cmpA.value = sl[0] || "All";
    if (cmpB.value === "All") cmpB.value = sl[1] || sl[0] || "All";
  }

  function subsetRows(rows, serviceLine, unitId){
    return rows.filter(r=>{
      const sl = String(getField(r,"service_line") ?? "").trim();
      const u = String(getField(r,"unit_id") ?? "").trim();
      const okSL = (!serviceLine || serviceLine==="All") ? true : sl === serviceLine;
      const okU  = (!unitId || unitId==="All") ? true : u === unitId;
      return okSL && okU;
    });
  }

  function recomputeTier3FromFilters(){
    if (!window.__lastEncounterRows) return;
    const rows = subsetRows(window.__lastEncounterRows, tier3Filter.service_line, tier3Filter.unit_id);
    const computed = computeFromEncounterRows(rows);
    tier3Baseline = computed;
    tier3Sim = null;
    simEdits = {};
    uploadedRaw = computed.pillarMetrics;
    setMode("upload", `Tier 3 auto-compute (filtered scope)`);
    setText("upload_status", `Encounter-level dataset active (filtered)`);
    setHTML("upload_meta", ` • Service line: <b>${tier3Filter.service_line}</b> • Unit: <b>${tier3Filter.unit_id}</b> • Encounters: <b>${rows.length.toLocaleString()}</b>`);
    updateAll();
    renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
  }

  function runServiceLineComparison(){
    const tbl = document.getElementById("tier3_compare_table");
    if (!tbl){
      return;
    }
    if (!window.__lastEncounterRows){
      tbl.innerHTML = "<tr><th>Comparison</th><th>Result</th></tr><tr><td colspan='2'>Upload an encounter-level dataset first.</td></tr>";
      return;
    }
    const cmpA = document.getElementById("cmp_a")?.value || "All";
    const cmpB = document.getElementById("cmp_b")?.value || "All";
    tier3Compare = {a: cmpA, b: cmpB};

    const rowsA = subsetRows(window.__lastEncounterRows, cmpA, tier3Filter.unit_id);
    const rowsB = subsetRows(window.__lastEncounterRows, cmpB, tier3Filter.unit_id);
    const compA = computeFromEncounterRows(rowsA);
    const compB = computeFromEncounterRows(rowsB);

    // Build table: pillar scores for A and B and delta
    const lines = [];
    lines.push(`<tr>
      <th>Pillar</th>
      <th>${cmpA} score</th>
      <th>${cmpB} score</th>
      <th>Δ (A−B)</th>
    </tr>`);

    for (const p of PILLAR_ORDER){
      const a1 = compA.pillarMetrics[p].m1, a2 = compA.pillarMetrics[p].m2;
      const b1 = compB.pillarMetrics[p].m1, b2 = compB.pillarMetrics[p].m2;
      const aScore = clamp((METRICS[p].weights[0]*a1) + (METRICS[p].weights[1]*a2),0,100);
      const bScore = clamp((METRICS[p].weights[0]*b1) + (METRICS[p].weights[1]*b2),0,100);
      const d = aScore - bScore;
      lines.push(`<tr>
        <td><b>${p}</b></td>
        <td>${aScore.toFixed(0)} <span class="small">(${rowsA.length})</span></td>
        <td>${bScore.toFixed(0)} <span class="small">(${rowsB.length})</span></td>
        <td>${(d>=0?"+":"") + d.toFixed(0)}</td>
      </tr>`);
    }

    // Also show LAI pulse
    const laiA = Object.values(compA.pillarMetrics).reduce((s,v,i)=> s + clamp((METRICS[PILLAR_ORDER[i]].weights[0]*v.m1)+(METRICS[PILLAR_ORDER[i]].weights[1]*v.m2),0,100),0) / PILLAR_ORDER.length;
    const laiB = Object.values(compB.pillarMetrics).reduce((s,v,i)=> s + clamp((METRICS[PILLAR_ORDER[i]].weights[0]*v.m1)+(METRICS[PILLAR_ORDER[i]].weights[1]*v.m2),0,100),0) / PILLAR_ORDER.length;

    lines.push(`<tr><td colspan="4" class="small"><b>LAI Pulse</b> — ${cmpA}: ${laiA.toFixed(0)} | ${cmpB}: ${laiB.toFixed(0)} (Unit filter: ${tier3Filter.unit_id})</td></tr>`);
    tbl.innerHTML = lines.join("");
  }

  // Action recommendation library (component -> action suggestions)
  const ACTION_LIBRARY = {
    "Access": {
      "median_delay_minutes": "Reduce interpreter delay: add an auto-trigger at registration/triage with an explicit SLA (e.g., ≤10 min) and escalation if not met.",
      "timestamp_integrity_pct": "Improve measurement integrity: make interpreter request/start timestamps required fields (EHR hard fields or smart form).",
      "request_reliability_pct": "Fix request reliability: require interpreter_required prompts at intake; audit ‘required but not requested’ encounters weekly for 30 days."
    },
    "Patient Experience": {
      "explained_yes_pct": "Standardize ‘clear explanation’ behaviors: teach-back script + visual aids at the highest-risk decision points; reinforce in rounding.",
      "listened_yes_pct": "Strengthen listening signals: introduce a 2-question ‘pause + confirm’ micro-protocol at triage and discharge with interpreter present."
    },
    "Outcomes": {
      "preventive_completed_pct": "Close follow-through gaps: add automated reminders and interpreter-supported follow-up scheduling before discharge.",
      "non_readmission_pct": "Target readmissions: prioritize teach-back + language-concordant discharge instructions for top 2 diagnoses driving returns."
    },
    "Compliance": {
      "section_1557_pct": "Make 1557 evidence audit-ready: standardize notice/acknowledgment capture at registration and store in a reportable field.",
      "clinical_language_pct": "Fix language traceability: enforce preferred language as required in demographics AND propagate to clinical note headers.",
      "timestamp_integrity_pct": "Ensure interpreter request/start timestamps are captured automatically (system time-stamps) to avoid manual reconciliation.",
      "touchpoints_complete_pct": "Add a discharge hard-stop: require touchpoint documentation completion before final discharge sign-off."
    },
    "Patient Engagement": {
      "teachback_doc_pct": "Scale teach-back: implement a 60–90 second teach-back script and a single-click documentation field embedded in discharge workflow.",
      "discharge_concordance_pct": "Improve discharge concordance: auto-generate discharge instructions in preferred language or route for rapid translation."
    },
    "Financial Stewardship": {
      "non_missed_reimb_pct": "Reduce leakage: implement a coding-ready checklist for CCM/TCM/critical-care documentation and monitor weekly denials/holds.",
      "rework_penalty_pct": "Lower rework burden: reduce coder/provider queries via completeness prompts and templated attestations (E/M, teaching, critical care)."
    },
    "Quality and Safety": {
      "non_adverse_event_pct": "Add a high-risk communication control: interpreter + teach-back required for medication changes and consent-heavy decisions.",
      "safety_event_reported_pct": "Improve detection: add a ‘language context’ field to safety reports and train staff to flag communication-related near misses."
    },
    "Workforce Development": {
      "training_current_pct": "Raise competency: run a 30-day training sprint for high-volume units; require completion for scheduling in LEP-heavy areas.",
      "qbs_pct": "Grow QBS capacity: identify top bilingual staff; enroll in QBS verification; redeploy to peak demand hours.",
      "language_match_pct": "Deploy concordance intentionally: schedule language-concordant clinicians for the top 3 LEP languages in your service area."
    },
    "Workflow Optimization": {
      "touchpoint_coverage_pct": "Standardize the 7-touchpoint workflow: embed interpreter/QBS prompts at each touchpoint (triage, H&P, diagnostics, vitals, follow-up, discharge planning, education).",
      "timestamp_integrity_pct": "Eliminate ‘silent failures’: ensure request/start timestamps are auto-captured to reveal where workflow breaks.",
      "touchpoints_complete_pct": "Reduce variability: add a workflow ‘hard-stop’ requiring touchpoint documentation completion for high-risk pathways."
    },
    "Technology Innovation": {
      "documentation_maturity_pct": "Improve documentation maturity: deploy smart phrases/templates for E/M basis, MDM elements, critical care, and teaching attestations.",
      "rework_penalty_pct": "Reduce friction: implement real-time completeness checks (EHR prompts) to prevent downstream follow-up tasks.",
      "tech_utilization_pct": "Increase tech utilization: standardize VRI availability and default to VRI/audio where in-person is delayed; monitor adoption weekly."
    }
  };

  function recommendActions(active, pillar){
    const listEl = document.getElementById("tier3_actions_list");
    const noteEl = document.getElementById("tier3_actions_note");
    if (!listEl || !noteEl) return;
    listEl.innerHTML = "";

    if (!active || !active.pillarDetails || !active.pillarDetails[pillar]){
      noteEl.textContent = "Upload an encounter-level dataset to generate recommendations.";
      return;
    }
    noteEl.textContent = "Recommendations are generated from the lowest component values for this pillar.";

    const det = active.pillarDetails[pillar];
    const comps = [...(det.components.kpi1||[]), ...(det.components.kpi2||[])];
    // Normalize to a 'low is bad' score for ranking
    const scored = comps.map(c=>{
      if (c.key === "median_delay_minutes"){
        const delayScore = delayScoreFromMedian(c.value);
        return {key:c.key, label:c.label, value: delayScore};
      }
      return {key:c.key, label:c.label, value: (typeof c.value==="number" ? c.value : null)};
    }).filter(x=>x.value!==null && x.value!==undefined);

    scored.sort((a,b)=>a.value-b.value);
    const low3 = scored.slice(0,3);

    const lib = ACTION_LIBRARY[pillar] || {};
    const actions = [];
    for (const c of low3){
      if (lib[c.key]) actions.push(lib[c.key]);
    }
    // If not enough mapped actions, add generic hypothesis prompts
    while (actions.length < 3){
      actions.push(`Run a 30-day improvement test targeting the lowest component (${low3[0]?.label || "this pillar"}) and re-measure.`);
    }

    actions.slice(0,3).forEach(a=>{
      const li=document.createElement("li");
      li.textContent = a;
      listEl.appendChild(li);
    });
  }


  // ---- Wire controls ----
  function wire(){
    document.querySelectorAll(".tabbtn").forEach(btn=> btn.addEventListener("click", ()=> setActiveView(btn.dataset.view)));
    document.getElementById("btn_reset").addEventListener("click", resetDefaults);
    document.getElementById("btn_expand").addEventListener("click", expandAll);
    document.getElementById("btn_collapse").addEventListener("click", collapseAll);
    document.getElementById("btn_export_json").addEventListener("click", exportInputsJSON);
    document.getElementById("btn_export_csv").addEventListener("click", exportScoresCSV);
    document.getElementById("btn_back_overview_1").addEventListener("click", ()=> setActiveView("overview"));
    document.getElementById("btn_go_pulse_1").addEventListener("click", ()=> setActiveView("pulse"));
    document.getElementById("btn_back_overview_2").addEventListener("click", ()=> setActiveView("overview"));
    document.getElementById("btn_go_pillar_2").addEventListener("click", ()=> setActiveView("pillar"));
    document.getElementById("btn_download_template").addEventListener("click", downloadTemplate);
    document.getElementById("btn_clear_upload").addEventListener("click", clearUpload);
    document.getElementById("file_input").addEventListener("change", (e)=>{
      const f=e.target.files && e.target.files[0];
      if (f) handleFile(f);
    });
    var el_chk_advanced_mode = document.getElementById("chk_advanced_mode");
    if (el_chk_advanced_mode) el_chk_advanced_mode.addEventListener("change", onAdvancedToggle);
    var el_chk_sim_mode = document.getElementById("chk_sim_mode");
    if (el_chk_sim_mode) el_chk_sim_mode.addEventListener("change", onSimToggle);
    var el_btn_sim_reset = document.getElementById("btn_sim_reset");
    if (el_btn_sim_reset) el_btn_sim_reset.addEventListener("click", resetSimulation);
    var el_tier3_pillar_select = document.getElementById("tier3_pillar_select");
    if (el_tier3_pillar_select) el_tier3_pillar_select.addEventListener("change", renderTier3Drilldown);
    var el_btn_apply_filters = document.getElementById("btn_apply_filters");
    if (el_btn_apply_filters) el_btn_apply_filters.addEventListener("click", ()=>{
      if(!window.__lastEncounterRows) { showErr("Upload an encounter-level dataset first."); return; }
      tier3Filter.service_line = document.getElementById("flt_service_line").value || "All";
      tier3Filter.unit_id = document.getElementById("flt_unit_id").value || "All";
      recomputeTier3FromFilters();
      runServiceLineComparison();
    });
    var el_btn_clear_filters = document.getElementById("btn_clear_filters");
    if (el_btn_clear_filters) el_btn_clear_filters.addEventListener("click", ()=>{
      if(!window.__lastEncounterRows) { showErr("Upload an encounter-level dataset first."); return; }
      tier3Filter = {service_line:"All", unit_id:"All"};
      document.getElementById("flt_service_line").value = "All";
      document.getElementById("flt_unit_id").value = "All";
      recomputeTier3FromFilters();
      runServiceLineComparison();
    });
    var el_btn_run_compare = document.getElementById("btn_run_compare");
    if (el_btn_run_compare) el_btn_run_compare.addEventListener("click", runServiceLineComparison);

  }

  // ---- Init ----
  function init(){
    try{
      if (typeof Plotly === "undefined"){
        showErr(`Plotly did not load. Charts will be disabled.`);
      } else if (typeof XLSX === "undefined"){
        showErr(`Excel parsing library did not load. Upload may not work.`);
      } else {
        showOk(`Dashboard loaded. For GitHub Pages, rename this file to <b>index.html</b> and ensure Pages is publishing the correct branch/folder.`);
      }
      buildPillars();
      buildPillarSelect();
      buildKpiTable();
      wire();
      setMode("manual", "Tier 1 proxy");
      resetDefaults();
      updateAll();
      // Re-render once external libs have fully loaded and layout has settled
      window.addEventListener('load', ()=>{ try{ updateAll(); }catch(e){} });
      setTimeout(()=>{ try{ updateAll(); }catch(e){} }, 250);
      renderTier3Drilldown();
      runServiceLineComparison();
      var ct=document.getElementById('tier3_compare_table');
      if(ct){ct.innerHTML = "<tr><th>Pillar</th><th>Compare A</th><th>Compare B</th><th>Δ</th></tr><tr><td colspan='4'>Upload an encounter-level dataset to enable comparison.</td></tr>";}
    } catch(e){
      showErr(`Initialization error: <code>${String(e)}</code>`);
      console.error(e);
    }
  }
  window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
