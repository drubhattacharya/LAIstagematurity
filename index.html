<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LAI Dashboard — 3 Tiers (Overview • Pillar • Pulse • Auto-Compute)</title>

  <!-- Plotly for charts -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <!-- SheetJS for Excel parsing -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --blue:#1f7fd6; --green:#18a76f; --ink:#0b1f33; --muted:#2f4556;
      --border:rgba(11,31,51,.16); --bg1:#e7f3ff; --bg2:#e7fbf2; --card:#ffffff;
      --warn:#d78b00; --bad:#d93b3b;
    }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1100px 520px at 15% 10%, var(--bg1), rgba(255,255,255,0)),
        radial-gradient(1100px 520px at 85% 20%, var(--bg2), rgba(255,255,255,0)),
        linear-gradient(180deg, #ffffff, #f7fbff);
      color:var(--ink); font-size:16px; line-height:1.45;
    }
    header{
      padding:14px 18px 12px 18px; border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.88); position:sticky; top:0; z-index:10; backdrop-filter: blur(8px);
    }
    .wrap{max-width:1250px;margin:0 auto;padding:14px 18px 40px;}
    h1{margin:0;font-size:20px;}
    .sub{margin-top:4px;color:var(--muted);font-size:13px;}
    .tabs{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .tabbtn{
      border:1px solid var(--border); background:#fff; border-radius:999px;
      padding:8px 12px; font-weight:900; cursor:pointer;
    }
    .tabbtn.active{border-color:rgba(31,127,214,.35); background:rgba(31,127,214,.08);}
    .grid{display:grid; gap:12px;}
    .grid-2{grid-template-columns:1.15fr 1fr;}
    @media (max-width: 980px){ .grid-2{grid-template-columns:1fr;} }
    .card{
      background:var(--card); border:1px solid var(--border); border-radius:16px;
      box-shadow:0 12px 28px rgba(11,31,51,.06); padding:14px;
    }
    .kpis{display:grid; grid-template-columns: repeat(4,1fr); gap:10px;}
    @media (max-width: 980px){ .kpis{grid-template-columns:1fr;} }
    .kpi{border:1px solid var(--border); border-radius:14px; padding:10px 12px; background:#fff;}
    .kpi .label{font-size:12px;color:var(--muted);font-weight:800;}
    .kpi .value{font-size:22px;font-weight:900;margin-top:2px;}
    .small{font-size:12px;color:var(--muted);}
    .pill{
      display:inline-block; padding:2px 10px; border-radius:999px;
      background:rgba(31,127,214,.10); border:1px solid rgba(31,127,214,.22);
      font-size:12px; font-weight:800;
    }
    .good{color:var(--green); font-weight:900;}
    .warn{color:var(--warn); font-weight:900;}
    .bad{color:var(--bad); font-weight:900;}
    .btnbar{display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px; align-items:center;}
    button{
      border:1px solid var(--border); background:#fff; border-radius:12px;
      padding:8px 12px; font-weight:900; cursor:pointer;
    }
    button.primary{border-color:rgba(31,127,214,.35); background:rgba(31,127,214,.08);}
    button.danger{border-color:rgba(217,59,59,.35); background:rgba(217,59,59,.08);}
    details{border:1px solid var(--border); border-radius:14px; padding:10px 12px; background:#fff; margin-top:10px;}
    summary{cursor:pointer; font-weight:900; color:var(--ink); list-style:none;}
    summary::-webkit-details-marker{display:none;}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .field{flex:1 1 320px; border:1px solid var(--border); border-radius:12px; padding:10px; background:#fff;}
    .field label{display:flex; justify-content:space-between; gap:10px; font-weight:900; font-size:13px;}
    .help{color:var(--muted); font-size:12px; margin-top:4px;}
    input[type="range"]{width:100%;}
    input, select{
      width:100%; padding:8px 10px; border:1px solid var(--border); border-radius:12px;
      font-size:14px; color:var(--ink); background:#fff;
    }
    .view{display:none;}
    .view.active{display:block;}
    .split{display:grid; grid-template-columns: 1.1fr .9fr; gap:12px;}
    @media (max-width: 980px){ .split{grid-template-columns:1fr;} }
    table{width:100%; border-collapse:collapse; font-size:13px;}
    th,td{border:1px solid var(--border); padding:8px; vertical-align:top;}
    th{background:rgba(31,127,214,.08); text-align:left;}
    .callout{border:1px dashed rgba(11,31,51,.25); border-radius:14px; padding:10px 12px; background: rgba(255,255,255,.7);}
    .errbar{display:none; border:1px solid rgba(217,59,59,.35); background:rgba(217,59,59,.08); color:var(--ink);
      border-radius:14px; padding:10px 12px; margin-top:12px;}
    .okbar{display:none; border:1px solid rgba(24,167,111,.35); background:rgba(24,167,111,.08); color:var(--ink);
      border-radius:14px; padding:10px 12px; margin-top:12px;}
    code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .inline{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--border); background:#fff;
      font-size:12px; font-weight:900; color:var(--ink);
    }
    .chip input{width:auto; padding:0; margin:0;}
  </style>
</head>

<body>
<header>
  <div class="wrap" style="padding:0 18px;">
    <h1>Language Access Index (LAI) — 3-Tier Navigation Dashboard</h1>
    <div class="sub">Tier 1: Preparedness proxy • Tier 2: Pillar drilldown • Tier 3: Performance validated from encounter-level evidence (optional Advanced Case Mode)</div>
    <div class="tabs" aria-label="Navigation tabs">
      <button class="tabbtn active" id="tab_overview" data-view="overview">Tier 1 — Overview</button>
      <button class="tabbtn" id="tab_pillar" data-view="pillar">Tier 2 — Pillar Deep Dive</button>
      <button class="tabbtn" id="tab_pulse" data-view="pulse">Tier 3 — LAI Pulse</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div id="errbar" class="errbar"></div>
  <div id="okbar" class="okbar"></div>

  <!-- OVERVIEW -->
  <section id="view_overview" class="view active">
    <div class="grid grid-2">
      <div class="card">
        <div class="btnbar">
          <button class="primary" id="btn_reset">Reset to defaults</button>
          <button id="btn_expand">Expand all pillars</button>
          <button id="btn_collapse">Collapse all pillars</button>
          <button id="btn_export_json">Export inputs (JSON)</button>
          <button id="btn_export_csv">Export scores (CSV)</button>
          <span class="chip" id="mode_chip">Mode: Manual (Tier 1)</span>
        </div>
        <div class="small">
          Tier 1 is a simplified preparedness proxy. Tier 3 can override Tier 1 using an encounter-level dataset (more precise).
        </div>
        <div id="pillars"></div>
      </div>

      <div class="card">
        <div class="kpis">
          <div class="kpi">
            <div class="label">LAI Pulse</div>
            <div class="value" id="lai_value">—</div>
            <div class="small" id="lai_band">—</div>
          </div>
          <div class="kpi">
            <div class="label">Risk signal</div>
            <div class="value" id="risk_label">—</div>
            <div class="small">Based on LAI thresholds</div>
          </div>
          <div class="kpi">
            <div class="label">Maturity stage</div>
            <div class="value" id="stage_label">—</div>
            <div class="small" id="stage_desc">—</div>
          </div>
          <div class="kpi">
            <div class="label">Top 3 improvement opportunities</div>
            <div class="small" id="opp_list">—</div>
          </div>
        </div>

        <div style="margin-top:10px;" id="gauge_overview"></div>
        <div style="margin-top:10px;" id="bar_overview"></div>

        <details>
          <summary>Pillar KPI reference (Tier 1 proxy inputs)</summary>
          <div style="margin-top:10px;">
            <table id="kpi_table"></table>
          </div>
        </details>
      </div>
    </div>
  </section>

  <!-- PILLAR DEEP DIVE -->
  <section id="view_pillar" class="view">
    <div class="grid">
      <div class="card">
        <div class="btnbar">
          <button class="primary" id="btn_back_overview_1">← Back to Overview</button>
          <button id="btn_go_pulse_1">Go to LAI Pulse →</button>
          <span class="chip" id="mode_chip_2">Mode: Manual (Tier 1)</span>
        </div>

        <div class="split">
          <div>
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <div style="font-weight:900;">Select pillar</div>
              <select id="pillar_select" style="max-width:420px;"></select>
              <span class="pill" id="pillar_score_badge">—</span>
            </div>
            <div class="small" style="margin-top:6px;">
              Tier 2 interprets signals from Tier 1 or Tier 3 (whichever is active) but does not change the underlying computation.
            </div>

            <div class="row" id="pillar_fields" style="margin-top:10px;"></div>

            <div class="callout" style="margin-top:10px;">
              <div style="font-weight:900;">Executive prompts (stage-aware)</div>
              <div class="small" id="exec_prompts" style="margin-top:6px;">—</div>
            </div>
          </div>

          <div>
            <div class="kpis" style="grid-template-columns:1fr; gap:10px;">
              <div class="kpi">
                <div class="label">Pillar score</div>
                <div class="value" id="pillar_score_value">—</div>
                <div class="small" id="pillar_score_band">—</div>
              </div>
              <div class="kpi">
                <div class="label">Nearest maturity “gate”</div>
                <div class="value" id="pillar_gate">—</div>
                <div class="small">Next stage threshold for this pillar</div>
              </div>
            </div>
            <div style="margin-top:10px;" id="pillar_gauge"></div>
            <div style="margin-top:10px;" id="pillar_breakdown"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- PULSE -->
  <section id="view_pulse" class="view">
    <div class="grid">
      <div class="card">
        <div class="btnbar">
          <button class="primary" id="btn_back_overview_2">← Back to Overview</button>
          <button id="btn_go_pillar_2">Go to Pillar Deep Dive →</button>
          <span class="chip" id="mode_chip_3">Mode: Manual (Tier 1)</span>
        </div>

        <!-- Upload card -->
        <div class="card" style="box-shadow:none; margin-bottom:12px;">
          <div style="font-weight:900; margin-bottom:6px;">Tier 3 Data Evidence Upload</div>
          <div class="small" style="margin-bottom:10px;">
            Upload an <b>.xlsx</b> (or <b>.csv</b>). Supported paths:
            <ul style="margin:6px 0 0 18px; padding:0;">
              <li><b>Encounter-level auto-compute (recommended):</b> sheet <code>Encounter_Level_Data</code> (computes all pillar KPIs from documented tasks and CPT signals).</li>
              <li><b>Pre-aggregated upload:</b> sheet <code>LAI_Pillar_Metrics</code> with <code>pillar_name</code>, <code>metric_1_value</code>, <code>metric_2_value</code>.</li>
            </ul>
          </div>

          <div class="inline">
            <input id="file_input" type="file" accept=".xlsx,.xls,.csv" />
            <button id="btn_download_template">Download template</button>
            <button class="danger" id="btn_clear_upload" disabled>Clear upload</button>

            <span class="chip" title="D2 weighting makes advanced maternal health encounters count more heavily in selected pillars.">
              <input type="checkbox" id="chk_advanced_mode" />
              <label for="chk_advanced_mode">Advanced Case Mode (D2)</label>
            </span>
          </div>

          <div class="small" style="margin-top:10px;">
            <b>Status:</b> <span id="upload_status">No file loaded.</span>
            <span id="upload_meta"></span>
          </div>
          <div class="small" style="margin-top:6px;">
            <b>Computation:</b> <span id="compute_mode">Tier 1 proxy</span>
          </div>
        </div>

        <div class="kpis">
          <div class="kpi">
            <div class="label">LAI Pulse</div>
            <div class="value" id="lai_value_2">—</div>
            <div class="small" id="lai_band_2">—</div>
          </div>
          <div class="kpi">
            <div class="label">Risk signal</div>
            <div class="value" id="risk_label_2">—</div>
            <div class="small">Based on LAI thresholds</div>
          </div>
          <div class="kpi">
            <div class="label">Maturity stage</div>
            <div class="value" id="stage_label_2">—</div>
            <div class="small" id="stage_desc_2">—</div>
          </div>
          <div class="kpi">
            <div class="label">Stage gate rationale</div>
            <div class="small" id="stage_rationale">—</div>
          </div>
        </div>

        <div class="grid grid-2" style="margin-top:10px;">
          <div class="card" style="box-shadow:none;">
            <div style="font-weight:900; margin-bottom:6px;">Pulse gauge</div>
            <div id="gauge_pulse"></div>
            <div class="small" style="margin-top:8px;">
              Tip: Stage is determined by LAI thresholds AND “weakest-link” pillar constraints.
            </div>
          </div>

          <div class="card" style="box-shadow:none;">
            <div style="font-weight:900; margin-bottom:6px;">Preparedness map (lowest pillars drive the gate)</div>
            <div id="heatmap_pulse"></div>
          </div>
        </div>

        <details>
          <summary>Tier 3 computation notes (why it differs from Tier 1)</summary>
          <div class="small" style="margin-top:8px;">
            <ul style="margin:0; padding-left:18px;">
              <li><b>Tier 1</b> uses simplified proxy inputs to estimate preparedness.</li>
              <li><b>Tier 3</b> computes pillar KPIs from documented tasks and evidence fields (e.g., E/M defensibility, MDM elements, touchpoint coverage completeness, CCM/TCM completeness, timestamp integrity, rework proxy).</li>
              <li><b>Advanced Case Mode (D2)</b> increases the weight of advanced maternal health encounters for selected pillars (risk-constrained maturity).</li>
            </ul>
          </div>
        </details>
      </div>
    </div>
  </section>
</div>

<script>
  // ---- Helpers ----
  function slugify(s){
    return String(s).toLowerCase().replace(/&/g,"and").replace(/[^a-z0-9]+/g,"_").replace(/^_+|_+$/g,"");
  }
  function clamp(x, lo=0, hi=100){ return Math.max(lo, Math.min(hi, x)); }

  function normKey(k){ return String(k||"").trim().toLowerCase(); }
  function yn(v){
    // normalize Yes/No variants
    const s = String(v ?? "").trim().toLowerCase();
    if (s === "yes" || s === "y" || s === "true" || s === "1") return 1;
    if (s === "no" || s === "n" || s === "false" || s === "0") return 0;
    return null; // missing/unknown
  }
  function num(v){
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
  function isMissing(v){
    return v === null || v === undefined || (typeof v === "string" && v.trim()==="");
  }

  function weightedMean(values, weights){
    let sw=0, sx=0;
    for (let i=0;i<values.length;i++){
      const w = weights[i];
      const x = values[i];
      if (x === null || x === undefined) continue;
      if (!Number.isFinite(w) || w<=0) continue;
      sw += w; sx += w*x;
    }
    return sw>0 ? sx/sw : null;
  }
  function weightedRate(indicators, weights){
    // indicators: 0/1 values, possibly null
    const m = weightedMean(indicators, weights);
    return m===null ? null : 100*m;
  }
  function weightedMedian(values, weights){
    // values numeric, weights positive
    const pairs = [];
    for (let i=0;i<values.length;i++){
      const v = values[i];
      const w = weights[i];
      if (v===null || v===undefined) continue;
      if (!Number.isFinite(v) || !Number.isFinite(w) || w<=0) continue;
      pairs.push([v,w]);
    }
    if (!pairs.length) return null;
    pairs.sort((a,b)=>a[0]-b[0]);
    const totalW = pairs.reduce((a,b)=>a+b[1],0);
    let cum=0;
    for (const [v,w] of pairs){
      cum += w;
      if (cum >= totalW/2) return v;
    }
    return pairs[pairs.length-1][0];
  }

  function delayScoreFromMedian(mins){
    if (mins===null || mins===undefined) return 0;
    if (mins <= 10) return 100;
    if (mins <= 15) return 80;
    if (mins <= 20) return 60;
    if (mins <= 25) return 40;
    return 20;
  }

  function setText(id, txt){ const el=document.getElementById(id); if (el) el.textContent = txt; }
  function setHTML(id, html){ const el=document.getElementById(id); if (el) el.innerHTML = html; }
  function showErr(msg){ const e=document.getElementById("errbar"); e.style.display="block"; e.innerHTML = msg; }
  function clearErr(){ const e=document.getElementById("errbar"); e.style.display="none"; e.innerHTML = ""; }
  function showOk(msg){ const o=document.getElementById("okbar"); o.style.display="block"; o.innerHTML = msg; }

  // ---- Tier 1 proxy schema (kept for continuity) ----
  const METRICS = {"Access":{"m1":{"label":"% LEP patients who had <10 min wait time for interpreter/QBS in the Emergency Room","input":"band","units":"","bands":[["Under 10 min (ideal)",100],["10–15 min",80],["15–20 min",60],["20–25 min",40],[">25 min",20]],"default":"15–20 min"},"m2":{"label":"% alignment of physicians who speak non-English language(s) with LEP population in the geographic service area","input":"percent","units":"%","default":50},"weights":[0.6,0.4]},"Patient Experience":{"m1":{"label":"% HCAHPS differential among LEP and non-LEP pts in providers explaining things clearly","input":"gap_band","units":"pp","bands":[[2,100],[5,80],[10,60],[15,40],[1000000000,20]],"default":8},"m2":{"label":"% HCAHPS differential among LEP and non-LEP patients in patients understanding their treatment regimens","input":"gap_band","units":"pp","bands":[[2,100],[5,80],[10,60],[15,40],[1000000000,20]],"default":10},"weights":[0.5,0.5]},"Outcomes":{"m1":{"label":"% LEP patients who had prescriptions written and filled","input":"percent","units":"%","default":70},"m2":{"label":"% LEP patients who received recommended preventive services","input":"percent","units":"%","default":60},"weights":[0.5,0.5]},"Compliance":{"m1":{"label":"% LEP patients with interpreter access for touch-points requiring clinical engagement","input":"percent","units":"%","default":75},"m2":{"label":"% LEP encounters with documented interpreter/QBS use (excluding waivers)","input":"percent","units":"%","default":70},"weights":[0.5,0.5]},"Patient Engagement":{"m1":{"label":"% LEP patients who received teach-back","input":"percent","units":"%","default":40},"m2":{"label":"% LEP post-visit follow-up reached (auto + manual if needed)","input":"percent","units":"%","default":55},"weights":[0.5,0.5]},"Financial Stewardship":{"m1":{"label":"System cost savings from best practices (annual)","input":"dollars","units":"$","cap":5000000,"default":750000},"m2":{"label":"Hospital savings from reduced LOS among LEP patients (annual, per hospital)","input":"dollars","units":"$","cap":1500000,"default":250000},"weights":[0.55,0.45]},"Quality and Safety":{"m1":{"label":"30-day readmission rate for LEP patients","input":"band","units":"","bands":[["Under 10% (ideal)",100],["10–15%",80],["15–20%",60],["20–25%",40],[">25%",20]],"default":"15–20%"},"m2":{"label":"Gap in physical harm from adverse events (LEP vs non-LEP)","input":"gap_band","units":"pp","bands":[[0.5,100],[1.0,80],[2.0,60],[3.0,40],[1000000000,20]],"default":1.5},"weights":[0.55,0.45]},"Workforce Development":{"m1":{"label":"% staff trained in language access policy & preferred modality","input":"percent","units":"%","default":65},"m2":{"label":"% providers who are Qualified Bilingual Staff (QBS) or enrolled in QBS training","input":"percent","units":"%","default":20},"weights":[0.5,0.5]},"Workflow Optimization":{"m1":{"label":"% LEP touchpoints with documented interpreter/QBS use (7-touchpoint workflow)","input":"percent","units":"%","default":55},"m2":{"label":"Safety preparedness to minimize risk of harm for LEP patients (1–5)","input":"likert","units":"level","default":3},"weights":[0.55,0.45]},"Technology Innovation":{"m1":{"label":"% departments with tablets supporting VRI + audio interpreter modalities","input":"percent","units":"%","default":60},"m2":{"label":"% departments using tech-enabled documentation & automation (EMR doc, automated teach-back, etc.)","input":"percent","units":"%","default":45},"weights":[0.5,0.5]}};

  // Pillars shown in dashboard
  const PILLAR_ORDER = ["Access","Patient Experience","Outcomes","Compliance","Patient Engagement","Financial Stewardship","Quality and Safety","Workforce Development","Workflow Optimization","Technology Innovation"];
  // Map to internal IDs and to the dataset naming (Quality & Safety differs)
  const PILLAR_DISPLAY_TO_ID = Object.fromEntries(PILLAR_ORDER.map(p=>[p, slugify(p)]));
  const PILLAR_ID_TO_DISPLAY = Object.fromEntries(PILLAR_ORDER.map(p=>[slugify(p), p]));

  // Stage model (unchanged)
  const STAGES = [
    {name:"Stage 0", min:0,  label:"Unstable",          desc:"Reactive, inconsistent infrastructure; high variance by unit/service line."},
    {name:"Stage 1", min:40, label:"Foundational",      desc:"Core capabilities exist, but performance is uneven; basic standardization underway."},
    {name:"Stage 2", min:60, label:"Operational",       desc:"Reliable workflows across most touchpoints; measurable gains; fewer preventable failures."},
    {name:"Stage 3", min:75, label:"Optimized",         desc:"Proactive monitoring, strong documentation fidelity, and predictable outcomes for LEP patients."},
    {name:"Stage 4", min:85, label:"High-Reliability",  desc:"Sustained, audited, and continuously improved; resilient to demand surges and staffing shocks."}
  ];
  function stageFrom(lai, pillarScores){
    let candidate = STAGES[0];
    for (const s of STAGES){ if (lai >= s.min) candidate = s; }
    const lowPillars = Object.entries(pillarScores).filter(([p,sc]) => sc < candidate.min);
    if (lowPillars.length === 0){
      return {stage:candidate, gatedBy:null, rationale:`All pillars meet ≥${candidate.min}.`};
    }
    let gatedStage = STAGES[0];
    for (let i = STAGES.length-1; i >= 0; i--){
      const s = STAGES[i];
      const fails = Object.entries(pillarScores).filter(([p,sc]) => sc < s.min);
      if (fails.length === 0){ gatedStage = s; break; }
    }
    lowPillars.sort((a,b)=>a[1]-b[1]);
    const limiter = lowPillars[0];
    return {
      stage:gatedStage,
      gatedBy:{pillar: limiter[0], score: limiter[1], needed: candidate.min},
      rationale:`Gate constraint: ${limiter[0]} is ${limiter[1].toFixed(0)}/100 (<${candidate.min}).`
    };
  }

  function readinessBand(lai){
    if (lai >= 80) return ["High readiness","Lower risk","good"];
    if (lai >= 60) return ["Moderate readiness","Moderate risk","warn"];
    return ["Low readiness","Higher risk","bad"];
  }

  // ---- Mode state ----
  let MODE = "manual";          // manual | upload
  let COMPUTE = "tier1_proxy";  // tier1_proxy | encounter_auto | pillar_agg
  let uploadedRaw = null;       // {pillar: {m1, m2}} where m1/m2 are raw inputs or scores depending on COMPUTE
  let uploadedMeta = {};

  function setMode(mode, computeModeLabel){
    MODE = mode;
    const label = (MODE === "upload") ? "Mode: Tier 3 Evidence" : "Mode: Manual (Tier 1)";
    ["mode_chip","mode_chip_2","mode_chip_3"].forEach(id=> setText(id, label));
    setText("compute_mode", computeModeLabel || (MODE==="upload" ? "Tier 3 evidence" : "Tier 1 proxy"));
    setManualEnabled(MODE !== "upload");
  }
  function setManualEnabled(enabled){
    for (const p of PILLAR_ORDER){
      for (const k of ["m1","m2"]){
        const el = document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__${k}`);
        if (el) el.disabled = !enabled;
      }
    }
    const r = document.getElementById("btn_reset");
    if (r) r.disabled = !enabled;
  }

  // ---- Tier 1 UI build ----
  const pillarsDiv = document.getElementById("pillars");
  function makeField(pillar, key, spec){
    const id = `${PILLAR_DISPLAY_TO_ID[pillar]}__${key}`;
    const field = document.createElement("div");
    field.className = "field";

    const label = document.createElement("label");
    const left = document.createElement("span"); left.textContent = spec.label;
    const right = document.createElement("span"); right.className="pill"; right.textContent = spec.units || "";
    label.appendChild(left); label.appendChild(right);

    const help = document.createElement("div"); help.className="help";
    let inputEl;

    if (spec.input === "percent"){
      inputEl = document.createElement("input");
      inputEl.type="range"; inputEl.min=0; inputEl.max=100; inputEl.step=1;
      inputEl.value = spec.default ?? 50;
      help.textContent = "Percent (higher is better).";
    } else if (spec.input === "band"){
      inputEl = document.createElement("select");
      for (const [opt,_] of spec.bands){
        const o=document.createElement("option"); o.value=opt; o.textContent=opt; inputEl.appendChild(o);
      }
      inputEl.value = spec.default ?? spec.bands[0][0];
      help.textContent = "Banded performance (best at top).";
    } else if (spec.input === "gap_band"){
      inputEl = document.createElement("input");
      inputEl.type="number"; inputEl.min=0; inputEl.max=50; inputEl.step=0.5;
      inputEl.value = spec.default ?? 5;
      help.textContent = "Absolute gap (pp). Lower is better (aim for 0).";
    } else if (spec.input === "dollars"){
      inputEl = document.createElement("input");
      inputEl.type="number"; inputEl.min=0; inputEl.max=spec.cap ?? 1000000; inputEl.step=25000;
      inputEl.value = spec.default ?? 0;
      help.textContent = `Annual dollars. Scaled 0–100 (cap $${Number(spec.cap||0).toLocaleString()}).`;
    } else if (spec.input === "likert"){
      inputEl = document.createElement("select");
      [1,2,3,4,5].forEach(v=>{ const o=document.createElement("option"); o.value=v; o.textContent=String(v); inputEl.appendChild(o); });
      inputEl.value = spec.default ?? 3;
      help.textContent = "Operational readiness (1=low, 5=high).";
    } else {
      inputEl = document.createElement("input");
      inputEl.type="range"; inputEl.min=0; inputEl.max=100; inputEl.step=1;
      inputEl.value = spec.default ?? 50;
      help.textContent = "Percent (higher is better).";
    }

    inputEl.id = id;
    inputEl.addEventListener("input", updateAll);
    inputEl.addEventListener("change", updateAll);

    const val = document.createElement("div");
    val.className="small"; val.style.marginTop="6px"; val.id = id + "__val";

    field.appendChild(label);
    field.appendChild(inputEl);
    field.appendChild(val);
    field.appendChild(help);
    return field;
  }

  function buildPillars(){
    pillarsDiv.innerHTML = "";
    for (const pillar of PILLAR_ORDER){
      const d=document.createElement("details");
      d.open = (pillar === "Access");
      const s=document.createElement("summary");
      s.innerHTML = `${pillar} <span class="small" id="score_${PILLAR_DISPLAY_TO_ID[pillar]}"></span>`;
      d.appendChild(s);

      const row=document.createElement("div"); row.className="row";
      row.appendChild(makeField(pillar,"m1",METRICS[pillar].m1));
      row.appendChild(makeField(pillar,"m2",METRICS[pillar].m2));
      d.appendChild(row);
      pillarsDiv.appendChild(d);
    }
  }

  function buildPillarSelect(){
    const sel=document.getElementById("pillar_select");
    sel.innerHTML="";
    for (const p of PILLAR_ORDER){
      const o=document.createElement("option"); o.value=p; o.textContent=p; sel.appendChild(o);
    }
    sel.addEventListener("change", renderPillarView);
  }

  // ---- Compute for Tier 1 or Tier 3 ----
  function getRaw(pillar, key, spec){
    // Tier 3 upload overrides
    if (MODE === "upload" && uploadedRaw && uploadedRaw[pillar] && uploadedRaw[pillar][key] != null){
      return uploadedRaw[pillar][key];
    }
    // Tier 1 controls
    const el=document.getElementById(`${PILLAR_DISPLAY_TO_ID[pillar]}__${key}`);
    if (!el) return spec.default;
    if (spec.input === "band") return el.value;
    return Number(el.value);
  }

  // Tier 3 upload always provides scores in v4; Tier 1 uses spec scoring.
  function scoreMetric(spec, raw){
    if (MODE === "upload"){
      return clamp(Number(raw)||0, 0, 100);
    }
    if (spec.input === "percent") return clamp(Number(raw)||0,0,100);
    if (spec.input === "band"){
      const map=new Map(spec.bands);
      return clamp(map.get(raw) ?? 0, 0, 100);
    }
    if (spec.input === "gap_band"){
      const a=Math.abs(Number(raw)||0);
      for (const [u,s] of spec.bands){ if (a <= u) return clamp(s,0,100); }
      return clamp(spec.bands[spec.bands.length-1][1],0,100);
    }
    if (spec.input === "dollars"){
      const v=Math.max(0,Number(raw)||0);
      const cap=Math.max(1,Number(spec.cap||1));
      return clamp((Math.log1p(v)/Math.log1p(cap))*100,0,100);
    }
    if (spec.input === "likert"){
      const v=Number(raw)||1;
      return clamp(((v-1)/4)*100,0,100);
    }
    return clamp(Number(raw)||0,0,100);
  }

  function compute(){
    const pillarScores = {};
    const metricScores = {};

    for (const pillar of PILLAR_ORDER){
      const w = METRICS[pillar].weights;
      const m1 = METRICS[pillar].m1;
      const m2 = METRICS[pillar].m2;

      const m1_raw = getRaw(pillar, "m1", m1);
      const m2_raw = getRaw(pillar, "m2", m2);

      const m1_score = scoreMetric(m1, m1_raw);
      const m2_score = scoreMetric(m2, m2_raw);

      const pscore = clamp((w[0]*m1_score) + (w[1]*m2_score), 0, 100);
      pillarScores[pillar] = pscore;

      metricScores[pillar] = {
        m1:{raw:m1_raw, score:m1_score, spec:m1, weight:w[0]},
        m2:{raw:m2_raw, score:m2_score, spec:m2, weight:w[1]}
      };

      // Update Tier 1 readouts (works even when disabled)
      const val1=document.getElementById(`${PILLAR_DISPLAY_TO_ID[pillar]}__m1__val`);
      const val2=document.getElementById(`${PILLAR_DISPLAY_TO_ID[pillar]}__m2__val`);
      if (val1) val1.textContent = `Score: ${m1_score.toFixed(0)}/100`;
      if (val2) val2.textContent = `Score: ${m2_score.toFixed(0)}/100`;

      const sc=document.getElementById(`score_${PILLAR_DISPLAY_TO_ID[pillar]}`);
      if (sc) sc.textContent = ` — ${pscore.toFixed(0)}/100`;
    }

    const lai = Object.values(pillarScores).reduce((a,b)=>a+b,0) / Math.max(1, PILLAR_ORDER.length);
    return {lai, pillarScores, metricScores};
  }

  // ---- Charts ----
  function canPlotly(){ return (typeof Plotly !== "undefined" && Plotly && Plotly.newPlot); }
  function renderGauge(divId, value, title){
    const el = document.getElementById(divId);
    if (!el) return;
    if (!canPlotly()){
      el.innerHTML = `<div class="small">Chart unavailable. Value: <b>${value.toFixed(0)}</b></div>`;
      return;
    }
    const data=[{type:"indicator", mode:"gauge+number", value:value, title:{text:title,font:{size:14}}, gauge:{axis:{range:[0,100]}}}];
    const layout={margin:{t:40,r:20,b:20,l:20}, height:240};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }
  function renderBar(divId, pillarScores){
    const el=document.getElementById(divId); if (!el) return;
    if (!canPlotly()){ el.innerHTML=`<div class="small">Chart unavailable.</div>`; return; }
    const x=Object.keys(pillarScores);
    const y=x.map(k=>pillarScores[k]);
    const data=[{type:"bar", x:x, y:y}];
    const layout={margin:{t:30,r:10,b:110,l:40}, height:320, xaxis:{tickangle:-35}, yaxis:{range:[0,100], title:"Score (0–100)"}};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }
  function renderPillarBreakdown(divId, pillar, metricScores){
    const el=document.getElementById(divId); if (!el) return;
    if (!canPlotly()){ el.innerHTML=`<div class="small">Chart unavailable.</div>`; return; }
    const ms=metricScores[pillar];
    const data=[{type:"bar", x:["KPI 1","KPI 2"], y:[ms.m1.score, ms.m2.score], hoverinfo:"y"}];
    const layout={margin:{t:20,r:10,b:40,l:40}, height:260, yaxis:{range:[0,100], title:"Score (0–100)"}};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }
  function renderHeatmap(divId, pillarScores){
    const el=document.getElementById(divId); if (!el) return;
    if (!canPlotly()){ el.innerHTML=`<div class="small">Chart unavailable.</div>`; return; }
    const x=PILLAR_ORDER;
    const z=[x.map(p=>pillarScores[p])];
    const data=[{type:"heatmap", x:x, y:["Pillars"], z:z, zmin:0, zmax:100, showscale:true}];
    const layout={margin:{t:10,r:10,b:90,l:50}, height:220};
    Plotly.newPlot(divId,data,layout,{displayModeBar:false,responsive:true});
  }

  // ---- KPI reference table (Tier 1 only) ----
  function buildKpiTable(){
    const tbl=document.getElementById("kpi_table");
    let html="<tr><th>Pillar</th><th>KPI</th><th>Input type</th><th>Weight</th><th>Default</th></tr>";
    for (const p of PILLAR_ORDER){
      html += `<tr><td rowspan="2"><b>${p}</b></td><td>${METRICS[p].m1.label}</td><td>${METRICS[p].m1.input}</td><td>${METRICS[p].weights[0]}</td><td>${METRICS[p].m1.default}</td></tr>`;
      html += `<tr><td>${METRICS[p].m2.label}</td><td>${METRICS[p].m2.input}</td><td>${METRICS[p].weights[1]}</td><td>${METRICS[p].m2.default}</td></tr>`;
    }
    tbl.innerHTML=html;
  }

  // ---- Views ----
  function setActiveView(view){
    document.querySelectorAll(".view").forEach(v=>v.classList.remove("active"));
    document.getElementById("view_"+view).classList.add("active");
    document.querySelectorAll(".tabbtn").forEach(b=>b.classList.remove("active"));
    document.getElementById("tab_"+view).classList.add("active");
    if (view === "pillar") renderPillarView();
    if (view === "pulse") renderPulseView();
    if (view === "overview") updateAll();
    window.scrollTo({top:0, behavior:"smooth"});
  }

  function renderPillarView(){
    const {pillarScores, metricScores} = compute();
    const p = document.getElementById("pillar_select").value || PILLAR_ORDER[0];

    const wrap=document.getElementById("pillar_fields");
    wrap.innerHTML="";
    const m1=metricScores[p].m1, m2=metricScores[p].m2;
    const f1=document.createElement("div"); f1.className="field";
    f1.innerHTML=`<label><span>${MODE==="upload" ? "Tier 3 KPI 1 (computed)" : "Tier 1 KPI 1 (proxy)"} — ${PILLAR_ORDER.includes(p)?p:""}</span><span class="pill">score</span></label>
      <div class="small" style="margin-top:6px;"><b>Score:</b> ${m1.score.toFixed(0)}/100</div>
      <div class="help">${MODE==="upload" ? "Computed from encounter-level evidence (tasks + documentation)." : "User-set proxy input."}</div>`;
    const f2=document.createElement("div"); f2.className="field";
    f2.innerHTML=`<label><span>${MODE==="upload" ? "Tier 3 KPI 2 (computed)" : "Tier 1 KPI 2 (proxy)"} — ${PILLAR_ORDER.includes(p)?p:""}</span><span class="pill">score</span></label>
      <div class="small" style="margin-top:6px;"><b>Score:</b> ${m2.score.toFixed(0)}/100</div>
      <div class="help">${MODE==="upload" ? "Computed from encounter-level evidence (tasks + documentation)." : "User-set proxy input."}</div>`;
    wrap.appendChild(f1); wrap.appendChild(f2);

    const score = pillarScores[p];
    setText("pillar_score_value", score.toFixed(0));
    const [rb,_,cls]=readinessBand(score);
    setText("pillar_score_band", rb);
    const badge=document.getElementById("pillar_score_badge");
    if (badge){ badge.classList.remove("good","warn","bad"); badge.classList.add(cls); badge.textContent=`${p}: ${score.toFixed(0)}/100`; }
    let next = STAGES.find(s=>score < s.min && s.min>0);
    if (!next) next = STAGES[STAGES.length-1];
    setText("pillar_gate", `≥${next.min}`);

    const prompts=[
      `Where is the evidence weakest in ${p}: missing timestamps, missing touchpoints, or missing attestations?`,
      `Which documentation element would most reduce rework (attendant task burden) in the next 30 days?`,
      `Which unit/service line is the outlier—and what control would reduce variance quickly?`,
      `What is the minimum evidence standard needed to reliably meet the next gate (≥${next.min})?`
    ];
    setText("exec_prompts", prompts.join(" "));

    renderGauge("pillar_gauge", score, `${p} — Pillar Score`);
    renderPillarBreakdown("pillar_breakdown", p, metricScores);
  }

  function renderPulseView(){
    const {lai, pillarScores} = compute();
    const [rb, rsk, cls] = readinessBand(lai);
    const st = stageFrom(lai, pillarScores);
    setText("lai_value_2", lai.toFixed(0));
    setText("lai_band_2", rb);
    setText("risk_label_2", rsk);
    setText("stage_label_2", `${st.stage.name}: ${st.stage.label}`);
    setText("stage_desc_2", st.stage.desc);
    setText("stage_rationale", st.rationale);
    renderGauge("gauge_pulse", lai, "LAI Pulse");
    renderHeatmap("heatmap_pulse", pillarScores);
  }

  function topOpportunities(pillarScores, n=3){
    return Object.entries(pillarScores).sort((a,b)=>a[1]-b[1]).slice(0,n);
  }

  function updateAll(){
    const {lai, pillarScores} = compute();
    const [rb, rsk, cls] = readinessBand(lai);
    const st = stageFrom(lai, pillarScores);
    const opp = topOpportunities(pillarScores, 3).map(([p,s])=>`${p} (${s.toFixed(0)})`).join(" • ");
    setText("lai_value", lai.toFixed(0));
    setText("lai_band", rb);
    setText("risk_label", rsk);
    setText("stage_label", `${st.stage.name}: ${st.stage.label}`);
    setText("stage_desc", st.stage.desc);
    setText("opp_list", opp || "—");
    renderGauge("gauge_overview", lai, "LAI Pulse");
    renderBar("bar_overview", pillarScores);
    if (document.getElementById("view_pillar").classList.contains("active")) renderPillarView();
    if (document.getElementById("view_pulse").classList.contains("active")) renderPulseView();
  }

  // ---- Tier 1 actions ----
  function resetDefaults(){
    if (MODE === "upload") return;
    for (const p of PILLAR_ORDER){
      for (const k of ["m1","m2"]){
        const spec=METRICS[p][k];
        const el=document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__${k}`);
        if (!el) continue;
        el.value = spec.default;
      }
    }
    updateAll();
  }
  function expandAll(){ document.querySelectorAll("#pillars details").forEach(d=>d.open=true); }
  function collapseAll(){ document.querySelectorAll("#pillars details").forEach(d=>d.open=false); }

  // ---- Downloads ----
  function downloadText(filename, text, mime="text/plain"){
    const blob = new Blob([text], {type:mime});
    const url = URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download=filename;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
  function exportInputsJSON(){
    const inputs = {};
    for (const p of PILLAR_ORDER){
      inputs[p] = {};
      for (const k of ["m1","m2"]){
        inputs[p][k] = getRaw(p,k,METRICS[p][k]);
      }
    }
    downloadText("lai_inputs.json", JSON.stringify(inputs,null,2), "application/json");
  }
  function exportScoresCSV(){
    const {lai, pillarScores} = compute();
    const rows=[["Metric","Score"],["LAI",lai.toFixed(2)],...PILLAR_ORDER.map(p=>[p,pillarScores[p].toFixed(2)])];
    const csv = rows.map(r=>r.map(v=>String(v).replaceAll('"','""')).map(v=>`"${v}"`).join(",")).join("\n");
    downloadText("lai_scores.csv", csv, "text/csv");
  }

  // ---- Template download (for LAI_Pillar_Metrics) ----
  function downloadTemplate(){
    const header=["pillar_name","metric_1_value","metric_2_value","denominator","reporting_period"];
    const rp="Q1 2026";
    const rows=[header.join(",")];
    for (const p of PILLAR_ORDER){
      rows.push([`"${p}"`,50,50,100,`"${rp}"`].join(","));
    }
    downloadText("LAI_Pillar_Metrics_template.csv", rows.join("\n"), "text/csv");
  }

  // ---- Tier 3 Auto-compute from Encounter_Level_Data ----
  function getAdvancedFlag(row){
    // prefer advanced_case_flag, else exemplar_type == advanced_maternal
    const a = yn(row["advanced_case_flag"]);
    if (a !== null) return a===1;
    const et = String(row["exemplar_type"] ?? "").trim().toLowerCase();
    return et === "advanced_maternal";
  }

  function weightsFor(rows, pillarName){
    const advMode = document.getElementById("chk_advanced_mode")?.checked;
    if (!advMode) return rows.map(_=>1);

    // D2: weight advanced maternal encounters heavier in selected pillars
    const heavyPillars = new Set(["Compliance","Quality and Safety","Workflow Optimization","Access"]);
    const base = rows.map(r=> getAdvancedFlag(r) ? 2 : 1);
    if (heavyPillars.has(pillarName)) return base;
    // other pillars remain equal weighting
    return rows.map(_=>1);
  }

  function computeReworkPenalty(rows, weights){
    // penalty up to 25% based on attendant_tasks_count
    const vals = rows.map(r=>{
      const t = num(r["attendant_tasks_count"]);
      if (t===null) return null;
      const tn = Math.min(t/10, 1); // cap at 10
      return tn;
    });
    const meanT = weightedMean(vals, weights);
    if (meanT===null) return 1;
    return clamp(1 - 0.25*meanT, 0.75, 1.0);
  }

  function computeIntegrity(rows, weights){
    // Among interpreter_requested==Yes: request & start timestamps documented
    const ind = [];
    const w = [];
    for (let i=0;i<rows.length;i++){
      const r=rows[i];
      const req = yn(r["interpreter_requested"]);
      if (req !== 1) continue;
      const ok = (yn(r["interp_request_documented"])===1 && yn(r["interp_start_documented"])===1) ? 1 : 0;
      ind.push(ok);
      w.push(weights[i]);
    }
    const rate = weightedRate(ind, w);
    return rate===null ? 0 : (rate/100);
  }

  function computeTouchpointRatio(row){
    const fields = [
      "interp_or_qbs_preassessment_triage",
      "interp_or_qbs_hp",
      "interp_or_qbs_diagnosticrev",
      "interp_or_qbs_vitals",
      "interp_or_qbs_followup",
      "interp_or_qbs_dischargeplan",
      "interp_or_qbs_pteduc"
    ];
    let numYes=0, denom=0;
    for (const f of fields){
      const v = yn(row[f]);
      if (v===null) continue;
      denom += 1;
      if (v===1) numYes += 1;
    }
    if (denom===0) return null;
    return numYes/denom;
  }

  function documentationMaturityComposite(rows, weights){
    // Components: E/M completeness, MDM index, critical care sufficiency, teaching attestation, CCM completeness, TCM completeness
    // Each component returns a rate 0..100 or null; weighted by "elements required"
    const components = [];

    // 1) E/M completeness
    {
      const ind = rows.map(r=> yn(r["doc_em_mdm_time_complete"]));
      const rate = weightedRate(ind.map(v=>v===null?null:v), weights);
      components.push({name:"em_complete", rate:rate, w:2});
    }

    // 2) MDM data documentation index (3 fields)
    {
      const vals = rows.map(r=>{
        const a=yn(r["mdm_data_review_documents_present"]);
        const b=yn(r["mdm_independent_interpretation_documented"]);
        const c=yn(r["mdm_discussion_external_provider_documented"]);
        const arr=[a,b,c].filter(x=>x!==null);
        if (!arr.length) return null;
        return arr.reduce((s,x)=>s+x,0)/arr.length; // 0..1
      });
      const mean = weightedMean(vals, weights);
      const rate = mean===null ? null : 100*mean;
      components.push({name:"mdm_index", rate:rate, w:3});
    }

    // 3) Critical care sufficiency among has_99291
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["has_99291"])!==1) continue;
        const def=yn(r["critical_care_met_definition_documented"])===1;
        const act=yn(r["critical_care_activities_documented"])===1;
        const t = num(r["critical_care_time_minutes_documented"])!==null;
        ind.push((def && act && t) ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"critical_care", rate:rate, w:3});
    }

    // 4) Teaching attestation among has_gc or has_ge
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (!(yn(r["has_gc"])===1 || yn(r["has_ge"])===1)) continue;
        ind.push(yn(r["doc_teaching_attestation_complete"])===1 ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"teaching", rate:rate, w:2});
    }

    // 5) CCM completeness among has_ccm
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["has_ccm"])!==1) continue;
        const c=yn(r["ccm_patient_consent_documented"])===1;
        const p=yn(r["ccm_care_plan_documented"])===1;
        const t = num(r["ccm_time_minutes_documented"])!==null;
        ind.push((c && p && t) ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"ccm", rate:rate, w:3});
    }

    // 6) TCM completeness among has_tcm
    {
      const ind=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["has_tcm"])!==1) continue;
        const d=yn(r["tcm_discharge_date_documented"])===1;
        const ic=yn(r["tcm_interactive_contact_made"])===1;
        const f2f=yn(r["tcm_face_to_face_visit_completed"])===1;
        ind.push((d && ic && f2f) ? 1 : 0);
        w.push(weights[i]);
      }
      const rate = weightedRate(ind, w);
      components.push({name:"tcm", rate:rate, w:3});
    }

    // Weighted mean of component rates (ignore null)
    let sw=0, sx=0;
    for (const c of components){
      if (c.rate===null || c.rate===undefined) continue;
      sw += c.w;
      sx += c.w * c.rate;
    }
    return sw>0 ? sx/sw : 0;
  }

  function computeFromEncounterRows(rows){
    // Compute two KPI scores (0..100) per pillar from encounter-level evidence fields
    const result = {};
    const reporting_period = rows[0]?.["reporting_quarter"] || rows[0]?.["reporting_period"] || "";
    const n = rows.length;

    // Access
    {
      const weights = weightsFor(rows,"Access");
      // median delay among interpreter_requested==Yes
      const delays=[]; const w=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["interpreter_requested"])!==1) continue;
        const d=num(r["interpreter_delay_minutes"]);
        if (d===null) continue;
        delays.push(d);
        w.push(weights[i]);
      }
      const med = weightedMedian(delays, w);
      const delayScore = delayScoreFromMedian(med);
      const integrity = computeIntegrity(rows, weights);
      const kpi1 = clamp(delayScore * integrity, 0, 100);

      // request reliability among interpreter_required==Yes
      const ind=[]; const ww=[];
      for (let i=0;i<rows.length;i++){
        const r=rows[i];
        if (yn(r["interpreter_required"])!==1) continue;
        ind.push(yn(r["interpreter_requested"])===1 ? 1 : 0);
        ww.push(weights[i]);
      }
      const kpi2 = weightedRate(ind, ww) ?? 0;

      result["Access"] = {m1:kpi1, m2:kpi2};
    }

    // Patient Experience
    {
      const weights = weightsFor(rows,"Patient Experience");
      const kpi1 = weightedRate(rows.map(r=>yn(r["provider_explained_understandably"])), weights) ?? 0;
      const kpi2 = weightedRate(rows.map(r=>yn(r["provider_listened"])), weights) ?? 0;
      result["Patient Experience"] = {m1:kpi1, m2:kpi2};
    }

    // Outcomes
    {
      const weights = weightsFor(rows,"Outcomes");
      const kpi1 = weightedRate(rows.map(r=>yn(r["preventive_service_completed"])), weights) ?? 0;
      const readm = weightedRate(rows.map(r=>yn(r["readmission_30d"])), weights) ?? 0;
      const kpi2 = clamp(100 - readm, 0, 100);
      result["Outcomes"] = {m1:kpi1, m2:kpi2};
    }

    // Compliance
    {
      const weights = weightsFor(rows,"Compliance");
      // composite: section_1557, clinical_language_documented, timestamp integrity (per encounter)
      const comp = rows.map(r=>{
        const a=yn(r["section_1557_documented"]);
        const b=yn(r["clinical_language_documented"]);
        const c=(yn(r["interp_request_documented"])===1 && yn(r["interp_start_documented"])===1) ? 1 : 0;
        const arr=[a,b,c].filter(x=>x!==null);
        if (!arr.length) return null;
        return arr.reduce((s,x)=>s+x,0)/arr.length; // 0..1
      });
      const kpi1 = (weightedMean(comp, weights) ?? 0) * 100;
      const kpi2 = weightedRate(rows.map(r=>yn(r["doc_interpreter_touchpoints_complete"])), weights) ?? 0;
      result["Compliance"] = {m1:clamp(kpi1,0,100), m2:kpi2};
    }

    // Patient Engagement
    {
      const weights = weightsFor(rows,"Patient Engagement");
      const kpi1 = weightedRate(rows.map(r=>yn(r["teach_back_documented"])), weights) ?? 0;
      const concord = rows.map(r=>{
        const a = String(r["discharge_instructions_language"] ?? "").trim().toLowerCase();
        const b = String(r["preferred_language"] ?? "").trim().toLowerCase();
        if (!a || !b) return null;
        return a===b ? 1 : 0;
      });
      const kpi2 = weightedRate(concord, weights) ?? 0;
      result["Patient Engagement"] = {m1:kpi1, m2:kpi2};
    }

    // Financial Stewardship
    {
      const weights = weightsFor(rows,"Financial Stewardship");
      const avoid = weightedRate(rows.map(r=>yn(r["avoidable_los_flag"])), weights) ?? 0;
      const miss = weightedRate(rows.map(r=>yn(r["missed_reimbursement_opportunity"])), weights) ?? 0;
      const kpi1 = clamp(100 - avoid, 0, 100);
      const kpi2_base = clamp(100 - miss, 0, 100);
      const penalty = computeReworkPenalty(rows, weights);
      const kpi2 = clamp(kpi2_base * penalty, 0, 100);
      result["Financial Stewardship"] = {m1:kpi1, m2:kpi2};
    }

    // Quality and Safety
    {
      const weights = weightsFor(rows,"Quality and Safety");
      const adv = weightedRate(rows.map(r=>yn(r["adverse_event_flag"])), weights) ?? 0;
      const kpi1 = clamp(100 - adv, 0, 100);
      const kpi2 = weightedRate(rows.map(r=>yn(r["safety_event_reported"])), weights) ?? 0;
      result["Quality and Safety"] = {m1:kpi1, m2:kpi2};
    }

    // Workforce Development
    {
      const weights = weightsFor(rows,"Workforce Development");
      const kpi1 = weightedRate(rows.map(r=>yn(r["staff_language_access_training_current"])), weights) ?? 0;
      const qbs = weightedRate(rows.map(r=>yn(r["provider_qbs_qualified"])), weights) ?? 0;
      const match = weightedRate(rows.map(r=>yn(r["provider_language_matches_patient"])), weights) ?? 0;
      const kpi2 = clamp((qbs + match)/2, 0, 100);
      result["Workforce Development"] = {m1:kpi1, m2:kpi2};
    }

    // Workflow Optimization
    {
      const weights = weightsFor(rows,"Workflow Optimization");
      const ratios = rows.map(r=>computeTouchpointRatio(r)); // 0..1
      const meanRatio = weightedMean(ratios, weights) ?? 0;
      const integrity = computeIntegrity(rows, weights);
      const kpi1 = clamp(100 * meanRatio * integrity, 0, 100);
      const kpi2 = weightedRate(rows.map(r=>yn(r["doc_interpreter_touchpoints_complete"])), weights) ?? 0;
      result["Workflow Optimization"] = {m1:kpi1, m2:kpi2};
    }

    // Technology Innovation
    {
      const weights = weightsFor(rows,"Technology Innovation");
      // tech utilization proxy: has_t1013 OR VRI modality
      const util = rows.map(r=>{
        const a = yn(r["has_t1013"]);
        const mod = String(r["interpreter_modality"] ?? "").trim().toLowerCase();
        const vri = (mod === "vri") ? 1 : 0;
        const arr=[a, vri].filter(x=>x!==null);
        if (!arr.length) return null;
        return arr.reduce((s,x)=>s+x,0)/arr.length; // 0..1
      });
      const utilRate = (weightedMean(util, weights) ?? 0) * 100;

      // tech integration level 1..5
      const ti = rows.map(r=>{
        const v = num(r["tech_integration_level"]);
        if (v===null) return null;
        return clamp(((v-1)/4)*100, 0, 100);
      });
      const tiScore = weightedMean(ti, weights) ?? 0;
      const kpi1 = clamp((utilRate + tiScore)/2, 0, 100);

      // documentation maturity composite + rework penalty
      const maturity = documentationMaturityComposite(rows, weights);
      const penalty = computeReworkPenalty(rows, weights);
      const kpi2 = clamp(maturity * penalty, 0, 100);

      result["Technology Innovation"] = {m1:kpi1, m2:kpi2};
    }

    return {pillarMetrics: result, meta:{n, reporting_period}};
  }

  // ---- Upload parsing ----
  async function handleFile(file){
    clearErr();
    if (!file) return;

    const ext = file.name.toLowerCase().split(".").pop();
    let wb=null;
    let csvText=null;

    try{
      if (ext === "csv"){
        csvText = await file.text();
      } else {
        if (typeof XLSX === "undefined") throw new Error("XLSX library did not load.");
        const buf = await file.arrayBuffer();
        wb = XLSX.read(buf, {type:"array"});
      }
    } catch(e){
      showErr(`Could not read file. Error: <code>${String(e)}</code>`);
      return;
    }

    // 1) If Excel and has Encounter_Level_Data => auto compute
    if (wb){
      const sheetLower = wb.SheetNames.map(n=>[n, n.trim().toLowerCase()]);
      const sheetEncounter = sheetLower.find(([n,l])=>l==="encounter_level_data");
      const sheetPillar = sheetLower.find(([n,l])=>l==="lai_pillar_metrics");

      if (sheetEncounter){
        const ws = wb.Sheets[sheetEncounter[0]];
        const rows = XLSX.utils.sheet_to_json(ws, {defval:""});

        // compute and load
        const computed = computeFromEncounterRows(rows);
        uploadedRaw = computed.pillarMetrics;
        uploadedMeta = {fileName:file.name, reporting_period: computed.meta.reporting_period, denominator_sum: computed.meta.n};

        setMode("upload", "Tier 3 auto-compute from Encounter_Level_Data");
        setText("upload_status", `Loaded encounter-level dataset: ${file.name}`);
        setHTML("upload_meta", ` • Reporting period: <b>${uploadedMeta.reporting_period || "—"}</b> • Encounters: <b>${uploadedMeta.denominator_sum.toLocaleString()}</b>`);
        document.getElementById("btn_clear_upload").disabled = false;
        COMPUTE = "encounter_auto";

        // sync Tier 1 controls to show scores (read-only) for transparency
        for (const p of PILLAR_ORDER){
          const el1=document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__m1`);
          const el2=document.getElementById(`${PILLAR_DISPLAY_TO_ID[p]}__m2`);
          if (el1) el1.value = 50;
          if (el2) el2.value = 50;
        }

        updateAll();
        showOk(`Tier 3 computed pillar KPIs from encounter-level evidence. Toggle “Advanced Case Mode (D2)” to re-weight advanced maternal health encounters.`);
        return;
      }

      // 2) else if has LAI_Pillar_Metrics => use pre-aggregated
      if (sheetPillar){
        const ws = wb.Sheets[sheetPillar[0]];
        const rows = XLSX.utils.sheet_to_json(ws, {defval:""});
        const mapped = {};

        const first = rows[0] || {};
        const cols = Object.keys(first);
        const findCol = (name)=> cols.find(c=>normKey(c)===normKey(name));

        const cP = findCol("pillar_name");
        const c1 = findCol("metric_1_value");
        const c2 = findCol("metric_2_value");
        const cD = findCol("denominator");
        const cR = findCol("reporting_period");

        if (!cP || !c1 || !c2){
          showErr(`LAI_Pillar_Metrics is missing required columns. Found: <code>${cols.join(", ")}</code>`);
          return;
        }

        let denomSum=0, rp=null;
        for (const r of rows){
          const name = String(r[cP] ?? "").trim();
          if (!name) continue;
          // match to our pillar names
          const match = PILLAR_ORDER.find(p=>p.toLowerCase() === name.toLowerCase());
          if (!match) continue;
          mapped[match] = {m1: Number(r[c1]), m2: Number(r[c2])};
          if (cD) denomSum += Number(r[cD])||0;
          if (!rp && cR && String(r[cR]||"").trim()) rp = String(r[cR]).trim();
        }
        const missing = PILLAR_ORDER.filter(p=>!mapped[p]);
        if (missing.length){
          showErr(`LAI_Pillar_Metrics parsed but missing pillars: <code>${missing.join(", ")}</code>.`);
          return;
        }
        uploadedRaw = mapped;
        uploadedMeta = {fileName:file.name, reporting_period: rp, denominator_sum: denomSum || rows.length};
        setMode("upload", "Tier 3 using uploaded LAI_Pillar_Metrics");
        setText("upload_status", `Loaded aggregated pillar metrics: ${file.name}`);
        setHTML("upload_meta", ` • Reporting period: <b>${rp || "—"}</b> • Denominator: <b>${(uploadedMeta.denominator_sum||0).toLocaleString()}</b>`);
        document.getElementById("btn_clear_upload").disabled = false;
        COMPUTE = "pillar_agg";
        updateAll();
        showOk(`Tier 3 loaded pre-aggregated pillar metrics. If you want automatic computation, include an Encounter_Level_Data sheet.`);
        return;
      }

      showErr(`Workbook does not contain <code>Encounter_Level_Data</code> or <code>LAI_Pillar_Metrics</code>. Found sheets: <code>${wb.SheetNames.join(", ")}</code>.`);
      return;
    }

    // CSV path: treat as LAI_Pillar_Metrics template
    if (csvText){
      const lines = csvText.split(/\r?\n/).filter(l=>l.trim().length>0);
      const headers = lines[0].split(",").map(h=>h.replace(/^"|"$/g,"").trim());
      const idx = (name)=> headers.findIndex(h=>normKey(h)===normKey(name));
      const iP = idx("pillar_name"), i1=idx("metric_1_value"), i2=idx("metric_2_value");
      if (iP<0 || i1<0 || i2<0){
        showErr(`CSV missing required columns. Required: pillar_name, metric_1_value, metric_2_value.`);
        return;
      }
      const mapped={};
      for (let i=1;i<lines.length;i++){
        const parts = lines[i].match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
        const get = (j)=> (parts[j] ?? "").replace(/^"|"$/g,"").trim();
        const pName = get(iP);
        const match = PILLAR_ORDER.find(p=>p.toLowerCase() === pName.toLowerCase());
        if (!match) continue;
        mapped[match] = {m1:Number(get(i1)), m2:Number(get(i2))};
      }
      const missing = PILLAR_ORDER.filter(p=>!mapped[p]);
      if (missing.length){
        showErr(`CSV parsed but missing pillars: <code>${missing.join(", ")}</code>.`);
        return;
      }
      uploadedRaw = mapped;
      uploadedMeta = {fileName:file.name};
      setMode("upload", "Tier 3 using uploaded pillar CSV");
      setText("upload_status", `Loaded aggregated pillar metrics: ${file.name}`);
      setHTML("upload_meta", "");
      document.getElementById("btn_clear_upload").disabled = false;
      COMPUTE = "pillar_agg";
      updateAll();
      showOk(`Tier 3 loaded pre-aggregated pillar metrics from CSV.`);
    }
  }

  function clearUpload(){
    uploadedRaw = null;
    uploadedMeta = {};
    document.getElementById("file_input").value = "";
    document.getElementById("btn_clear_upload").disabled = true;
    setText("upload_status", "No file loaded.");
    setHTML("upload_meta","");
    COMPUTE = "tier1_proxy";
    setMode("manual", "Tier 1 proxy");
    resetDefaults();
    showOk(`Upload cleared. Back to Tier 1 proxy mode.`);
  }

  // When advanced mode toggles, recompute if encounter-level is active
  function onAdvancedToggle(){
    if (MODE !== "upload" || COMPUTE !== "encounter_auto") return;
    // We don't store the raw encounter rows; for simplicity, require re-upload or keep last rows.
    // To keep it interactive, we cache the last encounter rows in memory.
    if (window.__lastEncounterRows){
      const computed = computeFromEncounterRows(window.__lastEncounterRows);
      uploadedRaw = computed.pillarMetrics;
      updateAll();
      showOk(`Advanced Case Mode ${document.getElementById("chk_advanced_mode").checked ? "ON" : "OFF"} — Tier 3 recomputed from encounter evidence.`);
    }
  }

  // Patch handleFile to cache rows on encounter compute
  const _handleFile = handleFile;
  handleFile = async function(file){
    // wrap to cache when encounter sheet is used
    clearErr();
    if (!file) return;
    const ext = file.name.toLowerCase().split(".").pop();
    if (ext === "csv"){
      return _handleFile(file);
    }
    if (typeof XLSX === "undefined"){
      showErr("XLSX library did not load.");
      return;
    }
    try{
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, {type:"array"});
      const sheetLower = wb.SheetNames.map(n=>[n, n.trim().toLowerCase()]);
      const sheetEncounter = sheetLower.find(([n,l])=>l==="encounter_level_data");
      if (sheetEncounter){
        const ws = wb.Sheets[sheetEncounter[0]];
        const rows = XLSX.utils.sheet_to_json(ws, {defval:""});
        window.__lastEncounterRows = rows;
      } else {
        window.__lastEncounterRows = null;
      }
      // delegate to original logic by using same file again (no re-read needed for simplicity)
      // We'll call the inner logic by temporarily setting a global and reusing parse with wb, but keep simple:
    } catch(e){
      // ignore cache if fails
      window.__lastEncounterRows = null;
    }
    // Now call original _handleFile which will re-read; acceptable for our size (~1000 rows)
    return _handleFile(file);
  }

  // ---- Wire controls ----
  function wire(){
    document.querySelectorAll(".tabbtn").forEach(btn=> btn.addEventListener("click", ()=> setActiveView(btn.dataset.view)));
    document.getElementById("btn_reset").addEventListener("click", resetDefaults);
    document.getElementById("btn_expand").addEventListener("click", expandAll);
    document.getElementById("btn_collapse").addEventListener("click", collapseAll);
    document.getElementById("btn_export_json").addEventListener("click", exportInputsJSON);
    document.getElementById("btn_export_csv").addEventListener("click", exportScoresCSV);
    document.getElementById("btn_back_overview_1").addEventListener("click", ()=> setActiveView("overview"));
    document.getElementById("btn_go_pulse_1").addEventListener("click", ()=> setActiveView("pulse"));
    document.getElementById("btn_back_overview_2").addEventListener("click", ()=> setActiveView("overview"));
    document.getElementById("btn_go_pillar_2").addEventListener("click", ()=> setActiveView("pillar"));
    document.getElementById("btn_download_template").addEventListener("click", downloadTemplate);
    document.getElementById("btn_clear_upload").addEventListener("click", clearUpload);
    document.getElementById("file_input").addEventListener("change", (e)=>{
      const f=e.target.files && e.target.files[0];
      if (f) handleFile(f);
    });
    document.getElementById("chk_advanced_mode").addEventListener("change", onAdvancedToggle);
  }

  // ---- Init ----
  function init(){
    try{
      if (typeof Plotly === "undefined"){
        showErr(`Plotly did not load. Charts will be disabled.`);
      } else if (typeof XLSX === "undefined"){
        showErr(`Excel parsing library did not load. Upload may not work.`);
      } else {
        showOk(`Dashboard loaded. For GitHub Pages, rename this file to <b>index.html</b> and ensure Pages is publishing the correct branch/folder.`);
      }
      buildPillars();
      buildPillarSelect();
      buildKpiTable();
      wire();
      setMode("manual", "Tier 1 proxy");
      resetDefaults();
      updateAll();
    } catch(e){
      showErr(`Initialization error: <code>${String(e)}</code>`);
      console.error(e);
    }
  }
  window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
